#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
mod libs {
    pub mod vigenere_trait {
        use anyhow::{bail, Result};
        use regex::Regex;
        use std::collections::HashMap;
        use crate::{
            traits::CharTrait,
            utils::{
                get_alphabet, get_char_by_index, modulus, validate_lang,
                SupportedLanguages,
            },
        };
        pub trait VigenereCipher {
            fn cipher<F>(
                lang: SupportedLanguages,
                key: &str,
                input: &str,
                f: F,
            ) -> Result<String>
            where
                F: Fn(i16, i16) -> i16,
            {
                <Self as VigenereCipher>::validate_language(&lang, key, input)?;
                let (alp, _, _, _, _, reg) = get_alphabet(&lang);
                let map: HashMap<char, usize> = HashMap::from_iter(
                    alp.chars().enumerate().map(|(idx, elem)| (elem, idx)),
                );
                let key = key.to_lowercase();
                let rg = Regex::new(reg).unwrap();
                let mut index = 0usize;
                let mut cipher_text = String::new();
                let key_len = key.chars().count();
                let alp_len = alp.chars().count() as i16;
                for c in input.chars() {
                    if !rg.is_match(&c.to_string()) {
                        cipher_text.push(c);
                        continue;
                    }
                    let key_idx = map
                        .get(&get_char_by_index(&key, index % key_len))
                        .unwrap()
                        .to_owned() as i16;
                    let text_idx = match c.is_lowercase() {
                        true => map.get(&c).unwrap(),
                        false => map.get(&c.to_lower_case()).unwrap(),
                    }
                        .to_owned() as i16;
                    let idx = f(text_idx, key_idx);
                    let plain_char = get_char_by_index(alp, modulus(idx, alp_len));
                    cipher_text
                        .push(
                            match c.is_lowercase() {
                                true => plain_char,
                                false => plain_char.to_upper_case(),
                            },
                        );
                    index += 1;
                }
                Ok(cipher_text)
            }
            fn validate_language(
                lang: &SupportedLanguages,
                key: &str,
                input: &str,
            ) -> Result<()> {
                if input.is_empty() {
                    return ::anyhow::__private::Err({
                        let error = ::anyhow::__private::format_err(
                            format_args!("Input is empty"),
                        );
                        error
                    });
                }
                if !validate_lang(key, lang) {
                    return ::anyhow::__private::Err({
                        let error = ::anyhow::__private::format_err(
                            format_args!("Invalid key"),
                        );
                        error
                    });
                }
                Ok(())
            }
        }
    }
    pub mod bacon {
        use std::collections::BTreeMap;
        use serde::Deserialize;
        use crate::utils::{get_alphabet, SupportedLanguages};
        pub struct BaconCipher {
            en_map: BTreeMap<char, String>,
            de_map: BTreeMap<String, String>,
        }
        impl BaconCipher {
            pub fn new(
                item_a: char,
                item_b: char,
                translation: SupportedBaconTranslation,
                alp: SupportedBaconAlphabet,
                lang: SupportedLanguages,
            ) -> Self {
                let (alphabet, _, _, _, length, _) = get_alphabet(&lang);
                let en_map = alphabet
                    .chars()
                    .map(|c| {
                        Self::char_by_alphabet(
                            c,
                            alphabet,
                            &translation,
                            &alp,
                            &length,
                            &item_a,
                            &item_b,
                        )
                    })
                    .collect();
                let de_map = alphabet
                    .chars()
                    .map(|c| {
                        let x = Self::char_by_alphabet(
                            c,
                            alphabet,
                            &translation,
                            &alp,
                            &length,
                            &item_a,
                            &item_b,
                        );
                        (x.1, x.0.to_string())
                    })
                    .collect();
                BaconCipher { en_map, de_map }
            }
            pub fn encode(&self, elem: &str) -> Vec<String> {
                elem.to_lowercase()
                    .chars()
                    .map(|x| match self.en_map.get(&x) {
                        None => x.to_string(),
                        Some(data) => data.to_owned(),
                    })
                    .collect()
            }
            pub fn decode(&self, elem: &str) -> Vec<String> {
                elem.split_whitespace()
                    .map(|x| match self.de_map.get(x) {
                        None => x.to_owned(),
                        Some(data) => data.to_owned(),
                    })
                    .collect()
            }
        }
        impl BaconCipher {
            fn char_by_alphabet(
                c: char,
                alphabet: &str,
                translation: &SupportedBaconTranslation,
                alp: &SupportedBaconAlphabet,
                length: &u8,
                a: &char,
                b: &char,
            ) -> (char, String) {
                let костыль = match alp {
                    SupportedBaconAlphabet::Standard => {
                        if ('a'..'j').contains(&c) {
                            0
                        } else if ('j'..'v').contains(&c) {
                            1
                        } else {
                            2
                        }
                    }
                    SupportedBaconAlphabet::Complete => 0,
                };
                let string = match (*length as f64).sqrt().round() as i8 {
                    5 => {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "{0:05b}",
                                alphabet.find(c).unwrap() - костыль,
                            ),
                        );
                        res
                    }
                    6 => {
                        let res = ::alloc::fmt::format(
                            format_args!("{0:06b}", alphabet.find(c).unwrap()),
                        );
                        res
                    }
                    _ => {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                }
                    .chars()
                    .map(|x| match translation {
                        SupportedBaconTranslation::ZeroOne => x,
                        SupportedBaconTranslation::AB => {
                            match x {
                                '0' => *a,
                                '1' => *b,
                                _ => {
                                    ::core::panicking::panic(
                                        "internal error: entered unreachable code",
                                    )
                                }
                            }
                        }
                    })
                    .collect();
                (c, string)
            }
        }
        impl Default for BaconCipher {
            fn default() -> Self {
                BaconCipher::new(
                    'A',
                    'B',
                    SupportedBaconTranslation::AB,
                    SupportedBaconAlphabet::Standard,
                    SupportedLanguages::EN,
                )
            }
        }
        pub enum SupportedBaconTranslation {
            #[serde(rename = "0/1")]
            ZeroOne,
            #[serde(rename = "A/B")]
            AB,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SupportedBaconTranslation {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "0/1" => _serde::__private::Ok(__Field::__field0),
                                "A/B" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"0/1" => _serde::__private::Ok(__Field::__field0),
                                b"A/B" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<
                            SupportedBaconTranslation,
                        >,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SupportedBaconTranslation;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum SupportedBaconTranslation",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedBaconTranslation::ZeroOne)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedBaconTranslation::AB)
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["0/1", "A/B"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "SupportedBaconTranslation",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                SupportedBaconTranslation,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub enum SupportedBaconAlphabet {
            #[serde(alias = "Standard (I=J and V=U)")]
            Standard,
            Complete,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SupportedBaconAlphabet {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Standard" | "Standard (I=J and V=U)" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                "Complete" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Standard" | b"Standard (I=J and V=U)" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                b"Complete" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SupportedBaconAlphabet>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SupportedBaconAlphabet;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum SupportedBaconAlphabet",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedBaconAlphabet::Standard)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedBaconAlphabet::Complete)
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["Standard", "Complete"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "SupportedBaconAlphabet",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                SupportedBaconAlphabet,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
    }
    pub mod base64 {
        use crate::{
            traits::StringTrait,
            utils::{
                expand_alphabet_range, get_char_by_index,
                str_to_array_buffer_by_alphabet, DataRepresentation,
                DataRepresentationInput,
            },
        };
        use anyhow::{anyhow, bail, Result};
        use itertools::Itertools;
        pub fn to_base64(data: &[u8], alphabet: Option<String>) -> Result<String> {
            if data.is_empty() {
                return Ok(String::new());
            }
            let alphabet = alphabet.unwrap_or("A-Za-z0-9+/=".to_string());
            let alphabet = String::from_iter(expand_alphabet_range(&alphabet));
            let alphabet_length = alphabet.chars().count();
            if alphabet_length != 64 && alphabet_length != 65 {
                return Err(
                    ::anyhow::__private::must_use({
                        let error = ::anyhow::__private::format_err(
                            format_args!(
                                "Invalid base64 alphabet length. ({0}):\n{1}",
                                alphabet_length,
                                alphabet,
                            ),
                        );
                        error
                    }),
                )?;
            }
            let mut output = String::new();
            let mut padding = 0;
            data.iter()
                .fold(
                    String::new(),
                    |acc, x| {
                        acc
                            + &{
                                let res = ::alloc::fmt::format(format_args!("{0:08b}", x));
                                res
                            }
                    },
                )
                .chars()
                .chunks(6)
                .into_iter()
                .map(|x| {
                    let sextet = x.collect::<String>();
                    match sextet.len() {
                        6 => u8::from_str_radix(&sextet, 2),
                        _ => {
                            padding += 1;
                            u8::from_str_radix(
                                &{
                                    let res = ::alloc::fmt::format(
                                        format_args!("{0:0<6}", sextet),
                                    );
                                    res
                                },
                                2,
                            )
                        }
                    }
                        .unwrap()
                })
                .for_each(|x| output.push(get_char_by_index(&alphabet, x)));
            output
                .push_str(
                    &match alphabet_length {
                        65 => {
                            get_char_by_index(&alphabet, 64).to_string().repeat(padding)
                        }
                        _ => "".to_string(),
                    },
                );
            Ok(output)
        }
        pub fn from_base64(
            mut data: String,
            mut alphabet: &str,
            return_type: DataRepresentationInput,
            remove_non_alphabetic_chars: bool,
            strict_mode: bool,
        ) -> Result<DataRepresentation> {
            if data.is_empty() {
                return match return_type {
                    DataRepresentationInput::String => {
                        Ok(DataRepresentation::String(String::new()))
                    }
                    DataRepresentationInput::ByteArray => {
                        Ok(DataRepresentation::ByteArray(Vec::new()))
                    }
                };
            }
            if alphabet.is_empty() {
                alphabet = "A-Za-z0-9+/=";
            }
            if !remove_non_alphabetic_chars {
                let regex = regex::Regex::new(
                        &{
                            let res = ::alloc::fmt::format(
                                format_args!("[^{0}]", alphabet),
                            );
                            res
                        },
                    )
                    .unwrap();
                if regex.is_match(&data) {
                    return ::anyhow::__private::Err({
                        let error = ::anyhow::__private::format_err(
                            format_args!(
                                "Input string isn\'t correspond to used base64 alphabet.",
                            ),
                        );
                        error
                    });
                }
            }
            let alphabet = expand_alphabet_range(alphabet).iter().collect::<String>();
            let alphabet_length = alphabet.chars().count();
            if alphabet_length != 64 && alphabet_length != 65 {
                return ::anyhow::__private::Err({
                    let error = ::anyhow::__private::format_err(
                        format_args!("Invalid base64 alphabet length."),
                    );
                    error
                });
            }
            if remove_non_alphabetic_chars {
                data = data.replace_by_alphabet(&alphabet);
            }
            if strict_mode {
                if data.len() % 4 == 1 {
                    return Err(
                        ::anyhow::Error::msg({
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "Invalid Base64 input length ({0}) cannot be 4n+1, even without padding chars.",
                                    data.len(),
                                ),
                            );
                            res
                        }),
                    );
                }
                if alphabet_length == 65 {
                    let pad = get_char_by_index(&alphabet, 64);
                    let pad_pos = data.find(pad);
                    if let Some(pad_pos) = pad_pos {
                        if pad_pos < data.len() - 2
                            || get_char_by_index(&data, data.len() - 1) != pad
                        {
                            return ::anyhow::__private::Err({
                                let error = ::anyhow::__private::format_err(
                                    format_args!(
                                        "Base64 padding character ({0}) not used in the correct place.",
                                        pad,
                                    ),
                                );
                                error
                            });
                        }
                        if data.len() % 4 != 0 {
                            return ::anyhow::__private::Err({
                                let error = ::anyhow::__private::format_err(
                                    format_args!("Base64 not padded to a multiple of 4."),
                                );
                                error
                            });
                        }
                    }
                }
            }
            if alphabet_length == 65 {
                data = data
                    .trim_end_matches(get_char_by_index(&alphabet, 64))
                    .to_string();
            }
            return match return_type {
                DataRepresentationInput::String => {
                    let mut output = String::new();
                    str_to_array_buffer_by_alphabet(&data, &alphabet)
                        .iter()
                        .map(|x| (
                            {
                                let res = ::alloc::fmt::format(format_args!("{0:08b}", x));
                                res
                            }[2..]
                                .to_string()
                        ))
                        .collect::<String>()
                        .chars()
                        .chunks(8)
                        .into_iter()
                        .map(|x| {
                            u8::from_str_radix(&x.collect::<String>(), 2).unwrap()
                                as char
                        })
                        .for_each(|x| output.push(x));
                    if output.ends_with('\u{0}') {
                        output = output[..output.len() - 1].to_string();
                    }
                    Ok(DataRepresentation::String(output))
                }
                DataRepresentationInput::ByteArray => {
                    let mut output = Vec::new();
                    str_to_array_buffer_by_alphabet(&data, &alphabet)
                        .iter()
                        .map(|x| (
                            {
                                let res = ::alloc::fmt::format(format_args!("{0:08b}", x));
                                res
                            }[2..]
                                .to_string()
                        ))
                        .collect::<String>()
                        .chars()
                        .chunks(8)
                        .into_iter()
                        .map(|x| u8::from_str_radix(&x.collect::<String>(), 2).unwrap())
                        .for_each(|x| output.push(x));
                    Ok(
                        DataRepresentation::ByteArray(
                            output[..output.len() - 1].to_vec(),
                        ),
                    )
                }
            };
        }
        #[allow(dead_code)]
        pub struct AlphabetOptions {
            name: &'static str,
            value: &'static str,
        }
        pub const _ALPHABET_OPTIONS: &[AlphabetOptions] = &[
            AlphabetOptions {
                name: "Standard (RFC 4648): A-Za-z0-9+/=",
                value: "A-Za-z0-9+/=",
            },
            AlphabetOptions {
                name: "URL safe (RFC 4648 §5): A-Za-z0-9-_",
                value: "A-Za-z0-9-_",
            },
            AlphabetOptions {
                name: "Filename safe: A-Za-z0-9+-=",
                value: "A-Za-z0-9+\\-=",
            },
            AlphabetOptions {
                name: "itoa64: ./0-9A-Za-z=",
                value: "./0-9A-Za-z=",
            },
            AlphabetOptions {
                name: "y64: A-Za-z0-9._-",
                value: "A-Za-z0-9._-",
            },
            AlphabetOptions {
                name: "z64: 0-9a-zA-Z+/=",
                value: "0-9a-zA-Z+/=",
            },
            AlphabetOptions {
                name: "Radix-64 (RFC 4880): 0-9A-Za-z+/=",
                value: "0-9A-Za-z+/=",
            },
            AlphabetOptions {
                name: "Uuencoding: [space]-_",
                value: " -_",
            },
            AlphabetOptions {
                name: "Xxencoding: +-0-9A-Za-z",
                value: "+\\-0-9A-Za-z",
            },
            AlphabetOptions {
                name: "BinHex: !-,-0-689@A-NP-VX-Z[`a-fh-mp-r",
                value: "!-,-0-689@A-NP-VX-Z[`a-fh-mp-r",
            },
            AlphabetOptions {
                name: "ROT13: N-ZA-Mn-za-m0-9+/=",
                value: "N-ZA-Mn-za-m0-9+/=",
            },
            AlphabetOptions {
                name: "UNIX crypt: ./0-9A-Za-z",
                value: "./0-9A-Za-z",
            },
            AlphabetOptions {
                name: "Atom128: /128GhIoPQROSTeUbADfgHijKLM+n0pFWXY456xyzB7=39VaqrstJklmNuZvwcdEC",
                value: "/128GhIoPQROSTeUbADfgHijKLM+n0pFWXY456xyzB7=39VaqrstJklmNuZvwcdEC",
            },
            AlphabetOptions {
                name: "Megan35: 3GHIJKLMNOPQRSTUb=cdefghijklmnopWXYZ/12+406789VaqrstuvwxyzABCDEF5",
                value: "3GHIJKLMNOPQRSTUb=cdefghijklmnopWXYZ/12+406789VaqrstuvwxyzABCDEF5",
            },
            AlphabetOptions {
                name: "Zong22: ZKj9n+yf0wDVX1s/5YbdxSo=ILaUpPBCHg8uvNO4klm6iJGhQ7eFrWczAMEq3RTt2",
                value: "ZKj9n+yf0wDVX1s/5YbdxSo=ILaUpPBCHg8uvNO4klm6iJGhQ7eFrWczAMEq3RTt2",
            },
            AlphabetOptions {
                name: "Hazz15: HNO4klm6ij9n+J2hyf0gzA8uvwDEq3X1Q7ZKeFrWcVTts/MRGYbdxSo=ILaUpPBC5",
                value: "HNO4klm6ij9n+J2hyf0gzA8uvwDEq3X1Q7ZKeFrWcVTts/MRGYbdxSo=ILaUpPBC5",
            },
        ];
    }
    pub mod bitwise_op {
        use serde::{Deserialize, Serialize};
        pub fn bit_op<F>(input: &[u8], key: &[u8], func: F) -> Vec<u8>
        where
            F: Fn(u8, u8) -> u8,
        {
            input.iter().enumerate().map(|(i, &e)| func(e, key[i % key.len()])).collect()
        }
        pub fn _xor(operand: u8, key: u8) -> u8 {
            operand ^ key
        }
        pub fn _not(operand: u8, _: u8) -> u8 {
            (!operand as i16 & 0xffi16) as u8
        }
        pub fn and(operand: u8, key: u8) -> u8 {
            operand & key
        }
        pub fn _or(operand: u8, key: u8) -> u8 {
            operand | key
        }
        pub fn add(operand: u8, key: u8) -> u8 {
            ((operand as i16 + key as i16) % 255) as u8
        }
        pub fn _sub(operand: u8, key: u8) -> u8 {
            let result = operand as i16 - key as i16;
            if result < 0 { (result + 256) as u8 } else { result as u8 }
        }
        #[serde(rename_all = "snake_case")]
        pub enum BitwiseOpDelimiters {
            Hex,
            Decimal,
            Binary,
            Base64,
            Utf8,
            Latin1,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for BitwiseOpDelimiters {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 6",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "hex" => _serde::__private::Ok(__Field::__field0),
                                "decimal" => _serde::__private::Ok(__Field::__field1),
                                "binary" => _serde::__private::Ok(__Field::__field2),
                                "base64" => _serde::__private::Ok(__Field::__field3),
                                "utf8" => _serde::__private::Ok(__Field::__field4),
                                "latin1" => _serde::__private::Ok(__Field::__field5),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"hex" => _serde::__private::Ok(__Field::__field0),
                                b"decimal" => _serde::__private::Ok(__Field::__field1),
                                b"binary" => _serde::__private::Ok(__Field::__field2),
                                b"base64" => _serde::__private::Ok(__Field::__field3),
                                b"utf8" => _serde::__private::Ok(__Field::__field4),
                                b"latin1" => _serde::__private::Ok(__Field::__field5),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<BitwiseOpDelimiters>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = BitwiseOpDelimiters;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum BitwiseOpDelimiters",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(BitwiseOpDelimiters::Hex)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(BitwiseOpDelimiters::Decimal)
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(BitwiseOpDelimiters::Binary)
                                }
                                (__Field::__field3, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(BitwiseOpDelimiters::Base64)
                                }
                                (__Field::__field4, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(BitwiseOpDelimiters::Utf8)
                                }
                                (__Field::__field5, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(BitwiseOpDelimiters::Latin1)
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "hex",
                        "decimal",
                        "binary",
                        "base64",
                        "utf8",
                        "latin1",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "BitwiseOpDelimiters",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                BitwiseOpDelimiters,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for BitwiseOpDelimiters {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        BitwiseOpDelimiters::Hex => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "BitwiseOpDelimiters",
                                0u32,
                                "hex",
                            )
                        }
                        BitwiseOpDelimiters::Decimal => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "BitwiseOpDelimiters",
                                1u32,
                                "decimal",
                            )
                        }
                        BitwiseOpDelimiters::Binary => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "BitwiseOpDelimiters",
                                2u32,
                                "binary",
                            )
                        }
                        BitwiseOpDelimiters::Base64 => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "BitwiseOpDelimiters",
                                3u32,
                                "base64",
                            )
                        }
                        BitwiseOpDelimiters::Utf8 => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "BitwiseOpDelimiters",
                                4u32,
                                "utf8",
                            )
                        }
                        BitwiseOpDelimiters::Latin1 => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "BitwiseOpDelimiters",
                                5u32,
                                "latin1",
                            )
                        }
                    }
                }
            }
        };
    }
    pub mod ciphers {
        use crate::{
            traits::CharTrait,
            utils::{
                get_alphabet, get_char_by_index, get_index_by_char, modulus,
                validate_lang, SupportedLanguages,
            },
        };
        use anyhow::{anyhow, bail, Result};
        use itertools::Itertools;
        use num::Integer;
        pub fn affine_cipher_encode(
            input: &str,
            lang: SupportedLanguages,
            a: i16,
            b: i16,
        ) -> Result<String> {
            if !validate_lang(input, &lang) {
                return ::anyhow::__private::Err({
                    let error = ::anyhow::__private::format_err(
                        format_args!("Wrong language."),
                    );
                    error
                });
            }
            let (alp_lower, alp_upper, _, _, alp_length, _) = get_alphabet(&lang);
            if a.gcd(&(alp_length as i16)) != 1 {
                return Err(
                    ::anyhow::Error::msg({
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "The value of `a` must be coprime to alphabet length({0}).",
                                alp_length,
                            ),
                        );
                        res
                    }),
                );
            }
            let mut output = String::with_capacity(alp_length as usize);
            for c in input.chars() {
                if !c.is_alphabetic() {
                    output.push(c);
                    continue;
                }
                let x = match c.is_lowercase() {
                    true => get_index_by_char(alp_lower, c),
                    false => get_index_by_char(alp_upper, c),
                } as i16;
                let x = modulus(a * x + b, alp_length as i16);
                output
                    .push(
                        match c.is_lowercase() {
                            true => get_char_by_index(alp_lower, x),
                            false => get_char_by_index(alp_upper, x).to_upper_case(),
                        },
                    );
            }
            Ok(output)
        }
        pub fn gen_polybius_square(
            alphabet: &SupportedLanguages,
            keyword: &str,
        ) -> Vec<char> {
            let (_, _, _, alpha, _, _) = get_alphabet(alphabet);
            let pol_array = {
                let res = ::alloc::fmt::format(format_args!("{0}{1}", keyword, alpha));
                res
            }
                .chars()
                .unique()
                .collect::<Vec<_>>();
            let size = match alphabet {
                SupportedLanguages::EN => 5,
                SupportedLanguages::RU | SupportedLanguages::RU_WITH_YO => 6,
            };
            let mut polybius: Vec<char> = Vec::new();
            for i in 0..size {
                polybius.extend(pol_array[i * size..i * size + size].iter());
            }
            polybius
        }
    }
}
mod macros {}
mod operations {
    pub mod a1z26_cipher_decode_mod {
        use crate::{
            create_info_struct, create_me_daddy, create_tauri_wrapper, run_operations,
            utils::char_repr, Operation, DOCS_URL,
        };
        use anyhow::{bail, Result};
        use serde::{Deserialize, Serialize};
        pub fn a1z26_cipher_decode(request: &str) -> Result<String, String> {
            run_operations(A1Z26CipherDecode, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__a1z26_cipher_decode;
        impl Operation<'_, DeserializeMeDaddy> for A1Z26CipherDecode {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let (input, delimiter) = (
                    request.input,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!("{0:?}", request.params.delimiter),
                        );
                        res
                    },
                );
                let delimiter = char_repr(&delimiter);
                let cipher_text = input.split(delimiter);
                let mut plain_text = String::new();
                for c in cipher_text {
                    let c = match c.parse::<u8>() {
                        Ok(c) => c,
                        Err(_) => continue,
                    };
                    if !(1..=26).contains(&c) {
                        return ::anyhow::__private::Err({
                            let error = ::anyhow::__private::format_err(
                                format_args!("All numbers must be between 1 and 26."),
                            );
                            error
                        });
                    }
                    plain_text.push((c + 96) as char);
                }
                Ok(plain_text)
            }
        }
        struct Params {
            delimiter: Delimiters,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Params {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "delimiter" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"delimiter" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Params>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Params;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Params",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                Delimiters,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Params with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Params { delimiter: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<Delimiters> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "delimiter",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Delimiters>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("delimiter")?
                                }
                            };
                            _serde::__private::Ok(Params { delimiter: __field0 })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["delimiter"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Params",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Params>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[allow(clippy::upper_case_acronyms)]
        pub enum Delimiters {
            Space,
            Comma,
            SemiColon,
            Colon,
            LineFeed,
            CRLF,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Delimiters {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 6",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Space" => _serde::__private::Ok(__Field::__field0),
                                "Comma" => _serde::__private::Ok(__Field::__field1),
                                "SemiColon" => _serde::__private::Ok(__Field::__field2),
                                "Colon" => _serde::__private::Ok(__Field::__field3),
                                "LineFeed" => _serde::__private::Ok(__Field::__field4),
                                "CRLF" => _serde::__private::Ok(__Field::__field5),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Space" => _serde::__private::Ok(__Field::__field0),
                                b"Comma" => _serde::__private::Ok(__Field::__field1),
                                b"SemiColon" => _serde::__private::Ok(__Field::__field2),
                                b"Colon" => _serde::__private::Ok(__Field::__field3),
                                b"LineFeed" => _serde::__private::Ok(__Field::__field4),
                                b"CRLF" => _serde::__private::Ok(__Field::__field5),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Delimiters>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Delimiters;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum Delimiters",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(Delimiters::Space)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(Delimiters::Comma)
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(Delimiters::SemiColon)
                                }
                                (__Field::__field3, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(Delimiters::Colon)
                                }
                                (__Field::__field4, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(Delimiters::LineFeed)
                                }
                                (__Field::__field5, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(Delimiters::CRLF)
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "Space",
                        "Comma",
                        "SemiColon",
                        "Colon",
                        "LineFeed",
                        "CRLF",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "Delimiters",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Delimiters>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(clippy::upper_case_acronyms)]
        impl ::core::fmt::Debug for Delimiters {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        Delimiters::Space => "Space",
                        Delimiters::Comma => "Comma",
                        Delimiters::SemiColon => "SemiColon",
                        Delimiters::Colon => "Colon",
                        Delimiters::LineFeed => "LineFeed",
                        Delimiters::CRLF => "CRLF",
                    },
                )
            }
        }
        #[automatically_derived]
        #[allow(clippy::upper_case_acronyms)]
        impl ::core::clone::Clone for Delimiters {
            #[inline]
            fn clone(&self) -> Delimiters {
                *self
            }
        }
        #[automatically_derived]
        #[allow(clippy::upper_case_acronyms)]
        impl ::core::marker::Copy for Delimiters {}
        struct DeserializeMeDaddy {
            input: String,
            params: Params,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                "params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                b"params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Params,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Params> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("params"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Params>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("params")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input", "params"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// A1Z26 is a simple substitution cipher where each letter is replaced by its serial number in the alphabet.
        /// <br/><br/>
        /// # How to use
        /// \
        /// Send POST requests to /api/A1Z26CipherDecode with your data using json payload with this structure
        /// ``` json
        /// {
        ///     "input": string,
        ///     "params": {
        ///         "delimiter": string
        ///     }
        /// }
        /// ```
        /// #### where
        ///     - delimiter is one of "Space", "Comma", "SemiColon", "Colon", "LineFeed", "CRLF"
        /// <br/><br/>
        ///
        /// ### Server response have two possible formats
        ///
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
        /// ``` json
        /// { "Ok": `some answer` }
        /// ```
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
        /// ``` json
        /// { "Err": `error message` }
        /// ```
        /// # Examples
        /// <br><br/>
        /// ## №1
        /// ``` http
        /// POST /api/A1Z26CipherDecode
        ///
        /// {
        ///     "input": "8 5 12 12 15",
        ///     "params": {
        ///         "delimiter": "Space"
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {
        ///   "Ok": "hello"
        /// }
        /// ```
        /// ## №2
        /// ``` http
        /// POST /api/A1Z26CipherDecode
        ///
        /// {
        ///     "input": "18;9;3;11;18;15;12;12",
        ///     "params": {
        ///         "delimiter": "Semi-colon"
        ///     }
        /// }
        /// ```
        /// ```http
        /// {
        ///   "Ok": "rickroll"
        /// }
        /// ```
        /// ## №3
        /// ``` http
        /// POST /api/A1Z26CipherDecode
        ///
        /// {
        ///     "input": "4 1 21 15 3",
        ///     "params": {
        ///         "delimiter": "Unsupported delimiter"
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 400 Bad Request
        /// {
        ///   "Err": "Invalid delimiter: `Unsupported delimiter`"
        /// }
        /// ```
        pub struct A1Z26CipherDecode;
        const NAME: &str = "A1Z26CipherDecode";
        const DESCRIPTION_EN: &str = "Converts alphabet order numbers into their corresponding alphabet character.";
        const DESCRIPTION_RU: &str = "Преобразует порядковые номера алфавита в соответствующие им символы алфавита.";
        const INFO_URL: Option<&str> = None;
        pub struct A1Z26CipherDecodeInfo {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for A1Z26CipherDecodeInfo {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "A1Z26CipherDecodeInfo",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl A1Z26CipherDecodeInfo {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub mod a1z26_cipher_encode_mod {
        use crate::{
            create_info_struct, create_me_daddy, create_tauri_wrapper,
            operations::Delimiters, run_operations, utils::char_repr, Operation, DOCS_URL,
        };
        use anyhow::Result;
        use serde::{Deserialize, Serialize};
        pub fn a1z26_cipher_encode(request: &str) -> Result<String, String> {
            run_operations(A1Z26CipherEncode, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__a1z26_cipher_encode;
        impl Operation<'_, DeserializeMeDaddy> for A1Z26CipherEncode {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let (input, delimiter) = (
                    request.input,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!("{0:?}", request.params.delimiter),
                        );
                        res
                    },
                );
                let mut result = String::new();
                let delimiter = char_repr(&delimiter);
                for character in input.chars() {
                    result
                        .push_str(
                            &match character {
                                'a'..='z' => {
                                    let res = ::alloc::fmt::format(
                                        format_args!("{0}{1}", character as u8 - 96, delimiter),
                                    );
                                    res
                                }
                                'A'..='Z' => {
                                    let res = ::alloc::fmt::format(
                                        format_args!("{0}{1}", character as u8 - 64, delimiter),
                                    );
                                    res
                                }
                                _ => "".to_string(),
                            },
                        );
                }
                if result.is_empty() {
                    return Ok(String::new());
                }
                Ok(result[..result.len() - 1].to_string())
            }
        }
        struct Params {
            delimiter: Delimiters,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Params {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "delimiter" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"delimiter" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Params>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Params;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Params",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                Delimiters,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Params with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Params { delimiter: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<Delimiters> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "delimiter",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Delimiters>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("delimiter")?
                                }
                            };
                            _serde::__private::Ok(Params { delimiter: __field0 })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["delimiter"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Params",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Params>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct DeserializeMeDaddy {
            input: String,
            params: Params,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                "params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                b"params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Params,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Params> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("params"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Params>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("params")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input", "params"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// A1Z26 is a simple substitution cipher where each letter is replaced by its serial number in the alphabet.
        /// <br/><br/>
        /// # How to use
        /// \
        /// Send POST requests to /api/A1Z26CipherEncode with your data using json payload with this structure
        /// ``` json
        /// {
        ///     "input": string,
        ///     "params": {
        ///         "delimiter": string
        ///     }
        /// }
        /// ```
        /// #### where
        ///     - delimiter is one of "Space", "Comma", "SemiColon", "Colon", "LineFeed", "CRLF"
        /// <br/><br/>
        ///
        /// ### Server response have two possible formats
        ///
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
        /// ``` json
        /// { "Ok": `some answer` }
        /// ```
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
        /// ``` json
        /// { "Err": `error message` }
        /// ```
        /// # Examples
        /// <br><br/>
        /// ## №1
        /// ``` http
        /// POST /api/A1Z26CipherEncode
        ///
        /// {
        ///     "input": "hello",
        ///     "params": {
        ///         "delimiter": "Space"
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {
        ///   "Ok": "8 5 12 12 15"
        /// }
        /// ```
        /// ## №2
        /// ``` http
        /// POST /api/A1Z26CipherDecode
        ///
        /// {
        ///     "input": "18;9;3;11;18;15;12;12",
        ///     "params": {
        ///         "delimiter": "Semi-colon"
        ///     }
        /// }
        /// ```
        /// ```http
        /// {
        ///   "Ok": "rickroll"
        /// }
        /// ```
        /// ## №3
        /// ``` http
        /// POST /api/A1Z26CipherDecode
        ///
        /// {
        ///     "input": "4 1 21 15 3",
        ///     "params": {
        ///         "delimiter": "Unsupported delimiter"
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 400 Bad Request
        /// {
        ///   "Err": "Invalid delimiter: `Unsupported delimiter`."
        /// }
        /// ```
        pub struct A1Z26CipherEncode;
        const NAME: &str = "A1Z26CipherEncode";
        const DESCRIPTION_EN: &str = "Converts alphabet characters into their corresponding alphabet order number.";
        const DESCRIPTION_RU: &str = "Преобразует символы алфавита в соответствующие им порядковые номера алфавита.";
        const INFO_URL: Option<&str> = None;
        pub struct A1Z26CipherEncodeInfo {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for A1Z26CipherEncodeInfo {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "A1Z26CipherEncodeInfo",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl A1Z26CipherEncodeInfo {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub mod add_line_numbers_mod {
        use crate::{
            create_info_struct, create_tauri_wrapper, run_operations, Operation, DOCS_URL,
        };
        use anyhow::Result;
        use serde::{Deserialize, Serialize};
        pub fn add_line_number(request: &str) -> Result<String, String> {
            run_operations(AddLineNumbers, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__add_line_number;
        impl Operation<'_, DeserializeMeDaddy> for AddLineNumbers {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let input = request.input;
                let output = input
                    .split('\n')
                    .enumerate()
                    .fold(
                        String::new(),
                        |acc, (i, x)| {
                            let index = " "
                                .repeat(input.len() - (i + 1).ilog10() as usize - 1)
                                .to_string() + &(i + 1).to_string();
                            acc
                                + &{
                                    let res = ::alloc::fmt::format(
                                        format_args!("{0} {1}", index, x),
                                    );
                                    res
                                }
                        },
                    );
                Ok(output)
            }
        }
        struct DeserializeMeDaddy {
            input: String,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub struct AddLineNumbers;
        const NAME: &str = "Add line numbers";
        const DESCRIPTION_EN: &str = "Adds line numbers to the output.";
        const DESCRIPTION_RU: &str = "Добавляет номера строк в выходные данные.";
        const INFO_URL: Option<&str> = None;
        pub struct AddLineNumbersInfo {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for AddLineNumbersInfo {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "AddLineNumbersInfo",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl AddLineNumbersInfo {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub mod add_mod {
        use crate::{
            create_info_struct, create_me_daddy, create_tauri_wrapper,
            libs::bitwise_op::{add as add_fun, bit_op},
            run_operations, utils::{convert_to_byte_array, SupportedFormats},
            Operation, DOCS_URL,
        };
        use anyhow::Result;
        use serde::{Deserialize, Serialize};
        pub fn add(request: &str) -> Result<String, String> {
            run_operations(ADD, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__add;
        impl Operation<'_, DeserializeMeDaddy> for ADD {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let (input, Params { key, key_format }) = (
                    request.input,
                    request.params,
                );
                let key = convert_to_byte_array(&key, &key_format)?;
                let output = String::from_utf8(bit_op(&key, input.as_bytes(), add_fun))?;
                Ok(output)
            }
        }
        struct Params {
            key: String,
            key_format: SupportedFormats,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Params {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "key" => _serde::__private::Ok(__Field::__field0),
                                "key_format" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"key" => _serde::__private::Ok(__Field::__field0),
                                b"key_format" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Params>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Params;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Params",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Params with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                SupportedFormats,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Params with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Params {
                                key: __field0,
                                key_format: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                SupportedFormats,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("key"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "key_format",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SupportedFormats,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("key")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("key_format")?
                                }
                            };
                            _serde::__private::Ok(Params {
                                key: __field0,
                                key_format: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["key", "key_format"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Params",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Params>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct DeserializeMeDaddy {
            input: String,
            params: Params,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                "params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                b"params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Params,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Params> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("params"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Params>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("params")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input", "params"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// ADD the input with the given key, MOD 255
        /// <br><br/>
        /// For more information go [here](https://wikipedia.org/wiki/Bitwise_operation#Bitwise_operators)
        /// <br><br/>
        ///
        /// # How to use
        /// \
        /// Send POST requests to /api/AND with your data using json payload with this structure
        /// ``` json
        /// {
        ///     "input": string,
        ///     "params": {
        ///         key: String,
        ///         key_format: SupportedFormats
        ///     }
        /// }
        /// ```
        /// #### where
        ///     SupportedFormats is enum of 'binary', 'utf8', 'hex', 'base64', 'latin1'
        /// <br/><br/>
        ///
        /// ### Server response have two possible formats
        ///
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
        /// ``` json
        /// { "Ok": `some answer` }
        /// ```
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
        /// ``` json
        /// { "Err": `error message` }
        /// ```
        /// # Examples
        /// ## №1
        /// ``` http
        /// POST /api/AND
        ///
        /// {
        ///     "input": "hello",
        ///     "params": {
        ///         key: "key",
        ///         key_format: "utf8"
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {
        ///   "Ok": "hehhe"
        /// }
        /// ```
        /// ## №2
        /// ``` http
        /// POST /api/AND
        ///
        /// {
        ///     "input": "hexadecimal",
        ///     "params": {
        ///         key: "deadbeef",
        ///         key_format: "hex"
        ///     }
        /// }
        /// ```
        /// ```http
        /// {
        ///   "Ok": "H%8aD%"iL!,"
        /// }
        /// ```
        /// ## №3
        /// ``` http
        /// POST /api/AND
        ///
        /// {
        ///     "input": "error",
        ///     "params": {
        ///         key: "no formet",
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 400 Bad Request
        /// {
        ///   "Err": "Missing field `key_format`"
        /// }
        /// ```
        pub struct ADD;
        const NAME: &str = "ADD";
        const DESCRIPTION_EN: &str = "ADD the input with the given key, MOD 255";
        const DESCRIPTION_RU: &str = "Применяет операцию ADD по модулю 255.";
        const INFO_URL: Option<&str> = Some(
            "https://wikipedia.org/wiki/Bitwise_operation#Bitwise_operators",
        );
        pub struct ADDInfo {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ADDInfo {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "ADDInfo",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl ADDInfo {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub mod adler32_checksum_mod {
        use crate::{
            create_info_struct, create_tauri_wrapper, run_operations, utils::hex,
            Operation, DOCS_URL,
        };
        use anyhow::Result;
        use serde::{Deserialize, Serialize};
        pub fn adler32_checksum(request: &str) -> Result<String, String> {
            run_operations(Adler32CheckSum, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__adler32_checksum;
        impl Operation<'_, DeserializeMeDaddy> for Adler32CheckSum {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let input: Vec<u8> = request.input.into();
                const MOD_ADLER: isize = 65521;
                let (mut a, mut b): (isize, isize) = (1, 0);
                for i in input.iter() {
                    a += *i as isize;
                    b += a;
                }
                a %= MOD_ADLER;
                b %= MOD_ADLER;
                Ok(hex(b << 16 | a))
            }
        }
        struct DeserializeMeDaddy {
            input: String,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub struct Adler32CheckSum;
        const NAME: &str = "Adler32CheckSum";
        const DESCRIPTION_EN: &str = "Adler-32 is a checksum algorithm which was invented by Mark Adler in 1995, and is a modification of the Fletcher checksum. Compared to a cyclic redundancy check of the same length, it trades reliability for speed (preferring the latter). Adler-32 is more reliable than Fletcher-16, and slightly less reliable than Fletcher-32.";
        const DESCRIPTION_RU: &str = "Adler-32 — алгоритм контрольной суммы, изобретенный Марком Адлером в 1995 году и являющийся модификацией контрольной суммы Флетчера. По сравнению с циклическим избыточным кодом той же продолжительности, он жертвует надежностью ради скорости (предпочитая последнюю). Адлер-32 более надежен, чем Флетчер-16, и немного менее надежен, чем Флетчер-32.";
        const INFO_URL: Option<&str> = Some("https://wikipedia.org/wiki/Adler-32");
        pub struct Adler32CheckSumInfo {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Adler32CheckSumInfo {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "Adler32CheckSumInfo",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl Adler32CheckSumInfo {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub mod affine_cipher_decode_mod {
        use crate::{
            create_info_struct, create_me_daddy, create_tauri_wrapper, run_operations,
            traits::{CharTrait, IntegerTrait},
            utils::{
                get_alphabet, get_char_by_index, get_index_by_char, mod_inv, modulus,
                validate_lang, SupportedLanguages,
            },
            Operation, DOCS_URL,
        };
        use anyhow::{anyhow, bail, Result};
        use serde::{Deserialize, Serialize};
        pub fn affine_cipher_decode(request: &str) -> Result<String, String> {
            run_operations(AffineCipherDecode, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__affine_cipher_decode;
        impl Operation<'_, DeserializeMeDaddy> for AffineCipherDecode {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let (input, params) = (request.input, request.params);
                if !validate_lang(&input, &params.lang) {
                    return ::anyhow::__private::Err({
                        let error = ::anyhow::__private::format_err(
                            format_args!("Wrong language."),
                        );
                        error
                    });
                }
                let (a, b) = (params.a as i16, params.b as i16);
                let (alp_lower, alp_upper, _, _, alp_length, _) = get_alphabet(
                    &params.lang,
                );
                if a.gcd(&(alp_length as i16)) != 1 {
                    return Err(
                        ::anyhow::Error::msg({
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "The value of `a` must be coprime to alphabet length({0}).",
                                    alp_length,
                                ),
                            );
                            res
                        }),
                    );
                }
                let mut output = String::with_capacity(alp_length as usize);
                for c in input.chars() {
                    if !c.is_alphabetic() {
                        output.push(c);
                        continue;
                    }
                    let y = match c.is_lowercase() {
                        true => get_index_by_char(alp_lower, c),
                        false => get_index_by_char(alp_upper, c),
                    } as i16;
                    let inv_a = mod_inv(a, alp_length as i16);
                    let x = modulus(inv_a * (y - b), alp_length as i16);
                    output
                        .push(
                            match c.is_lowercase() {
                                true => get_char_by_index(alp_lower, x),
                                false => get_char_by_index(alp_upper, x).to_upper_case(),
                            },
                        );
                }
                Ok(output)
            }
        }
        struct Params {
            lang: SupportedLanguages,
            a: u8,
            b: u8,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Params {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "lang" => _serde::__private::Ok(__Field::__field0),
                                "a" => _serde::__private::Ok(__Field::__field1),
                                "b" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"lang" => _serde::__private::Ok(__Field::__field0),
                                b"a" => _serde::__private::Ok(__Field::__field1),
                                b"b" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Params>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Params;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Params",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                SupportedLanguages,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Params with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                u8,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Params with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                u8,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct Params with 3 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Params {
                                lang: __field0,
                                a: __field1,
                                b: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                SupportedLanguages,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<u8> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<u8> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("lang"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SupportedLanguages,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("a"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("b"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("lang")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("a")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("b")?
                                }
                            };
                            _serde::__private::Ok(Params {
                                lang: __field0,
                                a: __field1,
                                b: __field2,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["lang", "a", "b"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Params",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Params>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct DeserializeMeDaddy {
            input: String,
            params: Params,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                "params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                b"params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Params,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Params> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("params"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Params>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("params")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input", "params"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// The Affine cipher is a type of monoalphabetic substitution cipher. To decrypt, each letter in an alphabet is mapped to its numeric equivalent, decrypted by a mathematical function, and converted back to a letter.
        /// <br><br/>
        /// For more information go [here](https://wikipedia.org/wiki/Affine_cipher)
        /// <br><br/>
        /// # How to use
        /// \
        /// Send POST requests to /api/AffineCipherDecode with your data using json payload with this structure
        /// ``` json
        /// {
        ///     "input": string,
        ///     "params": {
        ///         "lang": SupportedLanguages
        ///         "a": u8,
        ///         "b": u8,
        ///     }
        /// }
        /// ```
        /// #### where
        ///     - u8 is unsigned 8-bit integer (digit between 0 and 255)
        ///     - SupportedLanguages is enum of en, ru, ru_with_yo
        /// <br/><br/>
        ///
        /// ### Server response have two possible formats
        ///
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
        /// ``` json
        /// { "Ok": `some answer` }
        /// ```
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
        /// ``` json
        /// { "Err": `error message` }
        /// ```
        /// # Examples
        /// <br><br/>
        /// ## №1
        /// ``` http
        /// POST /api/AffineCipherDecode
        ///
        /// {
        ///     "input": "Cnwwl, Zlawi!",
        ///     "lang": "en",
        ///     "params": {
        ///         "a": 5,
        ///         "b": 19
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {
        ///   "Ok": "Hello, World!"
        /// }
        /// ```
        /// ## №2
        /// ``` http
        /// POST /api/AffineCipherDecode
        ///
        /// {
        ///     "input": "Мскньы, Юкс!",
        ///     "params": {
        ///         "a": 5,
        ///         "b" 3,
        ///     }
        /// }
        /// ```
        /// ```http
        /// {
        ///   "Ok": "Привет, Мир!"
        /// }
        /// ```
        /// ## №3
        /// ``` http
        /// POST /api/AffineCipherDecode
        ///
        /// {
        ///     "input": "Cnwwl, Zlawi!",
        ///     "lang": "en",
        ///     "params": {
        ///         "a": -5,
        ///         "b": 12735073052703957225979
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 400 Bad Request
        /// {
        ///   "Err": "Invalid value: integer `-5`, expected u8."
        /// }
        /// ```
        pub struct AffineCipherDecode;
        const NAME: &str = "AffineCipherDecode";
        const DESCRIPTION_EN: &str = "The Affine cipher is a type of monoalphabetic substitution cipher. To decrypt, each letter in an alphabet is mapped to its numeric equivalent, decrypted by a mathematical function, and converted back to a letter.";
        const DESCRIPTION_RU: &str = "Аффинный шифр — это тип моноалфавитного шифра замены. Чтобы расшифровать, каждая буква в алфавите сопоставляется с ее числовым эквивалентом, расшифровывается с помощью математической функции и преобразуется обратно в букву.";
        const INFO_URL: Option<&str> = Some("https://wikipedia.org/wiki/Affine_cipher");
        pub struct AffineCipherDecodeInfo {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for AffineCipherDecodeInfo {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "AffineCipherDecodeInfo",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl AffineCipherDecodeInfo {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub mod affine_cipher_encode_mod {
        use serde::{Deserialize, Serialize};
        use crate::{
            create_info_struct, create_me_daddy, create_tauri_wrapper,
            libs::ciphers::affine_cipher_encode as ace, run_operations,
            utils::SupportedLanguages, Operation, DOCS_URL,
        };
        use anyhow::Result;
        pub fn affine_cipher_encode(request: &str) -> Result<String, String> {
            run_operations(AffineCipherEncode, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__affine_cipher_encode;
        impl Operation<'_, DeserializeMeDaddy> for AffineCipherEncode {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let (input, lang, a, b) = (
                    request.input,
                    request.params.lang,
                    request.params.a as i16,
                    request.params.b as i16,
                );
                Ok(ace(&input, lang, a, b)?)
            }
        }
        struct Params {
            lang: SupportedLanguages,
            a: u8,
            b: u8,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Params {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "lang" => _serde::__private::Ok(__Field::__field0),
                                "a" => _serde::__private::Ok(__Field::__field1),
                                "b" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"lang" => _serde::__private::Ok(__Field::__field0),
                                b"a" => _serde::__private::Ok(__Field::__field1),
                                b"b" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Params>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Params;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Params",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                SupportedLanguages,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Params with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                u8,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Params with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                u8,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct Params with 3 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Params {
                                lang: __field0,
                                a: __field1,
                                b: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                SupportedLanguages,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<u8> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<u8> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("lang"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SupportedLanguages,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("a"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("b"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("lang")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("a")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("b")?
                                }
                            };
                            _serde::__private::Ok(Params {
                                lang: __field0,
                                a: __field1,
                                b: __field2,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["lang", "a", "b"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Params",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Params>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct DeserializeMeDaddy {
            input: String,
            params: Params,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                "params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                b"params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Params,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Params> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("params"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Params>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("params")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input", "params"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// The Affine cipher is a type of monoalphabetic substitution cipher. To decrypt, each letter in an alphabet is mapped to its numeric equivalent, decrypted by a mathematical function, and converted back to a letter.
        /// <br><br/>
        /// For more information go [here](https://wikipedia.org/wiki/Affine_cipher)
        /// <br><br/>
        /// # How to use
        /// \
        /// Send POST requests to /api/AffineCipherDecode with your data using json payload with this structure
        /// ``` json
        /// {
        ///     "input": string,
        ///     "params": {
        ///         "lang": SupportedLanguages
        ///         "a": u8,
        ///         "b": u8,
        ///     }
        /// }
        /// ```
        /// #### where
        ///     - u8 is unsigned 8-bit integer (digit between 0 and 255)
        ///     - SupportedLanguages is enum of en, ru, ru_with_yo
        /// <br/><br/>
        ///
        /// ### Server response have two possible formats
        ///
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
        /// ``` json
        /// { "Ok": `some answer` }
        /// ```
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
        /// ``` json
        /// { "Err": `error message` }
        /// ```
        /// # Examples
        /// <br><br/>
        /// ## №1
        /// ``` http
        /// POST /api/AffineCipherEncode
        ///
        /// {
        ///     "input": "Hello, World!",
        ///     "params": {
        ///         "lang": "en",
        ///         "a": 5,
        ///         "b": 3
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {
        ///   "Ok": "Mxggv, Jvkgs!"
        /// }
        /// ```
        /// ## №2
        /// ``` http
        /// POST /api/AffineCipherEncode
        ///
        /// {
        ///     "input": "Привет, Мир!",
        ///     "params": {
        ///         "lang": "ru",
        ///         "a": 5,
        ///         "b" 3,
        ///     }
        /// }
        /// ```
        /// ```http
        /// {
        ///   "Ok": "Мскньы, Юкс!"
        /// }
        /// ```
        /// ## №3
        /// ``` http
        /// POST /api/AffineCipherEncode
        ///
        /// {
        ///     "input": "Hello, World!",
        ///     "params": {
        ///         "lang": "en",
        ///         "a": -5,
        ///         "b": 12735073052703957225979
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 400 Bad Request
        /// {
        ///   "Err": "Invalid value: integer `-5`, expected u8."
        /// }
        /// ```
        pub struct AffineCipherEncode;
        const NAME: &str = "AffineCipherEncode";
        const DESCRIPTION_EN: &str = "The Affine cipher is a type of monoalphabetic substitution cipher. To decrypt, each letter in an alphabet is mapped to its numeric equivalent, decrypted by a mathematical function, and converted back to a letter.";
        const DESCRIPTION_RU: &str = "Аффинный шифр — это тип моноалфавитного шифра замены. Чтобы расшифровать, каждая буква в алфавите сопоставляется с ее числовым эквивалентом, расшифровывается с помощью математической функции и преобразуется обратно в букву.";
        const INFO_URL: Option<&str> = Some("https://wikipedia.org/wiki/Affine_cipher");
        pub struct AffineCipherEncodeInfo {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for AffineCipherEncodeInfo {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "AffineCipherEncodeInfo",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl AffineCipherEncodeInfo {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub mod analyse_hash_mod {
        use crate::{
            create_info_struct, create_tauri_wrapper, run_operations, Operation, DOCS_URL,
        };
        use anyhow::Result;
        use serde::{Deserialize, Serialize};
        pub fn analyse_hash(request: &str) -> Result<String, String> {
            run_operations(AnalyseHash, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__analyse_hash;
        impl Operation<'_, DeserializeMeDaddy> for AnalyseHash {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let input = request
                    .input
                    .chars()
                    .map(|x| match x {
                        '\t' | '\n' | ' ' => "".to_string(),
                        _ => x.to_string(),
                    })
                    .collect::<String>();
                let hash_length = input.len();
                let byte_length: f64 = hash_length as f64 / 2.0;
                let bit_length: f64 = byte_length * 8.0;
                let possible_hash_functions = match bit_length as u16 {
                    4 => {
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([
                                "Fletcher-4",
                                "Luhn algorithm",
                                "Verhoeff algorithm",
                            ]),
                        )
                    }
                    8 => {
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new(["Fletcher-8"]),
                        )
                    }
                    16 => {
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([
                                "BSD checksum",
                                "CRC-16",
                                "SYSV checksum",
                                "Fletcher-16",
                            ]),
                        )
                    }
                    32 => {
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([
                                "CRC-32",
                                "Fletcher-32",
                                "Adler-32",
                            ]),
                        )
                    }
                    64 => {
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new(["CRC-64", "RIPEMD-64", "SipHash"]),
                        )
                    }
                    128 => {
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([
                                "MD5",
                                "MD4",
                                "MD2",
                                "HAVAL-128",
                                "RIPEMD-128",
                                "Snefru",
                                "Tiger-128",
                            ]),
                        )
                    }
                    160 => {
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([
                                "SHA-1",
                                "SHA-0",
                                "FSB-160",
                                "HAS-160",
                                "HAVAL-160",
                                "RIPEMD-160",
                                "Tiger-160",
                            ]),
                        )
                    }
                    192 => {
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new(["Tiger", "HAVAL-192"]),
                        )
                    }
                    224 => {
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([
                                "SHA-224",
                                "SHA3-224",
                                "ECOH-224",
                                "FSB-224",
                                "HAVAL-224",
                            ]),
                        )
                    }
                    256 => {
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([
                                "SHA-256",
                                "SHA3-256",
                                "BLAKE-256",
                                "ECOH-256",
                                "FSB-256",
                                "GOST",
                                "Grøstl-256",
                                "HAVAL-256",
                                "PANAMA",
                                "RIPEMD-256",
                                "Snefru",
                            ]),
                        )
                    }
                    320 => {
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new(["RIPEMD-320"]),
                        )
                    }
                    384 => {
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([
                                "SHA-384",
                                "SHA3-384",
                                "ECOH-384",
                                "FSB-384",
                            ]),
                        )
                    }
                    512 => {
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([
                                "SHA-512",
                                "SHA3-512",
                                "BLAKE-512",
                                "ECOH-512",
                                "FSB-512",
                                "Grøstl-512",
                                "JH",
                                "MD6",
                                "Spectral Hash",
                                "SWIFFT",
                                "Whirlpool",
                            ]),
                        )
                    }
                    1024 => {
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new(["Fowler-Noll-Vo"]),
                        )
                    }
                    _ => {
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new(["Unknown"]),
                        )
                    }
                };
                let result = {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0} {1} {2} {3}",
                            hash_length,
                            byte_length,
                            bit_length,
                            possible_hash_functions.join(" "),
                        ),
                    );
                    res
                };
                Ok(result)
            }
        }
        pub struct SerializeMeDaddy {
            hash_length: usize,
            byte_length: f64,
            bit_length: f64,
            possible_hash_functions: Vec<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for SerializeMeDaddy {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "SerializeMeDaddy",
                        false as usize + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "hash_length",
                        &self.hash_length,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "byte_length",
                        &self.byte_length,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "bit_length",
                        &self.bit_length,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "possible_hash_functions",
                        &self.possible_hash_functions,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        struct DeserializeMeDaddy {
            input: String,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// This function tries to determine information about a given hash and suggests which algorithm may have been used to generate it based on its length.
        /// <br><br/>
        /// For more information go [here](https://wikipedia.org/wiki/Argon2)
        /// <br/><br/>
        ///
        /// # How to use
        /// \
        /// Send Post request to /api/AnalyseHash with your data using json payload with this structure
        /// ``` json
        /// {
        ///     "input": string,
        /// }
        /// ```
        /// ### Server response have two possible formats
        ///
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
        /// ``` json
        /// {
        ///     "Ok": {
        ///         "hash_length": int,
        ///         "byte_length": float,
        ///         "bit_length": float,
        ///         "possible_hash_functions": [string]
        ///     }
        /// }
        /// #### where
        ///     - [string] is array of string
        ///
        /// ```
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
        /// ``` json
        /// { "Err": `error message` }
        /// ```
        /// # Examples
        /// ## №1
        /// ``` http
        /// POST /api/Argon2
        ///
        /// {
        ///     "input": "5eafacd17b1ee3cf06c4ef8e4e33ab31a86a62a1e9b8dda71c04c830",
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {yc
        ///     "Ok": {
        ///         "hash_length": 56,
        ///         "byte_length": 28.0,
        ///         "bit_length": 224.0,
        ///         "possible_hash_functions": [
        ///             "SHA-224",
        ///             "SHA3-224",
        ///             "ECOH-224",
        ///             "FSB-224",
        ///             "HAVAL-224"
        ///         ]
        ///     }
        /// }
        /// ```
        /// ## №2
        /// ``` http
        /// POST /api/Argon2
        ///
        /// {
        ///     "input": "867f9b0a82ec4923c5da5ff362fa67b745768294",
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {
        ///     "Ok": {
        ///         "hash_length": 40,
        ///         "byte_length": 20.0,
        ///         "bit_length": 160.0,
        ///         "possible_hash_functions": [
        ///             "SHA-1",
        ///             "SHA-0",
        ///             "FSB-160",
        ///             "HAS-160",
        ///             "HAVAL-160",
        ///             "RIPEMD-160",
        ///             "Tiger-160"
        ///         ]
        ///     }
        /// }
        /// ```
        /// ## №3
        /// ``` http
        /// POST /api/Argon2
        ///
        /// {
        ///     "no_input": "",
        /// }
        /// ```
        /// ```http
        /// {
        ///     "Err": "Missing field `input`."
        /// }
        /// ```
        struct AnalyseHash;
        const NAME: &str = "AnalyseHash";
        const DESCRIPTION_EN: &str = "Tries to determine information about a given hash and suggests which algorithm may have been used to generate it based on its length.";
        const DESCRIPTION_RU: &str = "Пытается определить информацию о заданном хэше и предлагает, какой алгоритм мог быть использован для его генерации, исходя из его длины.";
        const INFO_URL: Option<&str> = Some(
            "https://wikipedia.org/wiki/Comparison_of_cryptographic_hash_functions",
        );
        pub struct AnalyseHashInfo {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for AnalyseHashInfo {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "AnalyseHashInfo",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl AnalyseHashInfo {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub mod and_mod {
        use crate::{
            create_info_struct, create_me_daddy, create_tauri_wrapper,
            libs::bitwise_op::{and as and_fun, bit_op},
            run_operations, utils::{convert_to_byte_array, SupportedFormats},
            Operation, DOCS_URL,
        };
        use anyhow::Result;
        use serde::{Deserialize, Serialize};
        pub fn and(request: &str) -> Result<String, String> {
            run_operations(AND, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__and;
        impl Operation<'_, DeserializeMeDaddy> for AND {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let (input, Params { key, key_format }) = (
                    request.input,
                    request.params,
                );
                let key = convert_to_byte_array(&key, &key_format)?;
                let output = String::from_utf8(bit_op(&key, input.as_bytes(), and_fun))?;
                Ok(output)
            }
        }
        struct Params {
            key: String,
            key_format: SupportedFormats,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Params {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "key" => _serde::__private::Ok(__Field::__field0),
                                "key_format" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"key" => _serde::__private::Ok(__Field::__field0),
                                b"key_format" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Params>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Params;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Params",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Params with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                SupportedFormats,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Params with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Params {
                                key: __field0,
                                key_format: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                SupportedFormats,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("key"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "key_format",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SupportedFormats,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("key")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("key_format")?
                                }
                            };
                            _serde::__private::Ok(Params {
                                key: __field0,
                                key_format: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["key", "key_format"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Params",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Params>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct DeserializeMeDaddy {
            input: String,
            params: Params,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                "params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                b"params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Params,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Params> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("params"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Params>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("params")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input", "params"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// AND the input with the given key.
        /// <br><br/>
        /// For more information go [here](https://wikipedia.org/wiki/Bitwise_operation#Bitwise_operators)
        /// <br><br/>
        ///
        /// # How to use
        /// \
        /// Send POST requests to /api/AND with your data using json payload with this structure
        /// ``` json
        /// {
        ///     "input": string,
        ///     "params": {
        ///         key: String,
        ///         key_format: SupportedFormats
        ///     }
        /// }
        /// ```
        /// #### where
        ///     SupportedFormats is enum of 'binary', 'utf8', 'hex', 'base64', 'latin1'
        /// <br/><br/>
        ///
        /// ### Server response have two possible formats
        ///
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
        /// ``` json
        /// { "Ok": `some answer` }
        /// ```
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
        /// ``` json
        /// { "Err": `error message` }
        /// ```
        /// # Examples
        /// ## №1
        /// ``` http
        /// POST /api/AND
        ///
        /// {
        ///     "input": "hello",
        ///     "params": {
        ///         key: "key",
        ///         key_format: "utf8"
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {
        ///   "Ok": "hehhe"
        /// }
        /// ```
        /// ## №2
        /// ``` http
        /// POST /api/AND
        ///
        /// {
        ///     "input": "hexadecimal",
        ///     "params": {
        ///         key: "deadbeef",
        ///         key_format: "hex"
        ///     }
        /// }
        /// ```
        /// ```http
        /// {
        ///   "Ok": "H%8aD%"iL!,"
        /// }
        /// ```
        /// ## №3
        /// ``` http
        /// POST /api/AND
        ///
        /// {
        ///     "input": "error",
        ///     "params": {
        ///         key: "no formet",
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 400 Bad Request
        /// {
        ///   "Err": "Missing field `key_format`"
        /// }
        /// ```
        pub struct AND;
        const NAME: &str = "AND";
        const DESCRIPTION_EN: &str = "AND the input with the given key.";
        const DESCRIPTION_RU: &str = "Применяет операцию ADD по модулю 255.";
        const INFO_URL: Option<&str> = Some(
            "https://wikipedia.org/wiki/Bitwise_operation#AND",
        );
        pub struct ANDInfo {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ANDInfo {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "ANDInfo",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl ANDInfo {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub mod argon2_compare_mod {
        use crate::{
            create_info_struct, create_me_daddy, create_tauri_wrapper, run_operations,
            Operation, DOCS_URL,
        };
        use anyhow::{anyhow, Result};
        use serde::{Deserialize, Serialize};
        pub fn argon2_compare(request: &str) -> Result<String, String> {
            run_operations(Argon2Compare, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__argon2_compare;
        impl Operation<'_, DeserializeMeDaddy> for Argon2Compare {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let (input, encoded_hash) = (request.input, request.params.encoded_hash);
                let res = argon2::verify_encoded(&encoded_hash, input.as_bytes())?;
                match res {
                    true => {
                        Ok({
                            let res = ::alloc::fmt::format(
                                format_args!("Match `{0}`.", input),
                            );
                            res
                        })
                    }
                    false => {
                        Err(
                            ::anyhow::__private::must_use({
                                let error = ::anyhow::__private::format_err(
                                    format_args!("No match."),
                                );
                                error
                            }),
                        )
                    }
                }
            }
        }
        struct Params {
            encoded_hash: String,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Params {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "encoded_hash" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"encoded_hash" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Params>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Params;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Params",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Params with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Params { encoded_hash: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "encoded_hash",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("encoded_hash")?
                                }
                            };
                            _serde::__private::Ok(Params { encoded_hash: __field0 })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["encoded_hash"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Params",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Params>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct DeserializeMeDaddy {
            input: String,
            params: Params,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                "params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                b"params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Params,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Params> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("params"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Params>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("params")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input", "params"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// Tests whether the input matches the given Argon2 hash. To test multiple possible passwords, use the 'Fork' operation.
        /// <br><br/>
        /// For more information go [here](https://wikipedia.org/wiki/Argon2)
        /// <br><br/>
        ///
        /// # How to use
        /// \
        /// Send POST requests to /api/Argon2Compare with your data using json payload with this structure
        /// ``` json
        /// {
        ///     "input": string,
        ///     "params": {
        ///         "encoded_hash": EncodedHash,
        ///     }
        /// }
        /// ```
        /// #### where
        ///     - EncodedHash is argon2 hash which look like that $argon2i$v=19$m=4096,t=3,p=1$c29tZXNhbHQ$WVDOfucSPAey3UEzzqLtBwRbGS83pTyIPLXgjhKfgrY
        /// <br/><br/>
        ///
        /// ### Server response have two possible formats
        ///
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
        /// ``` json
        /// { "Ok": `some answer` }
        /// ```
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
        /// ``` json
        /// { "Err": `error message` }
        /// ```
        /// # Examples
        /// ## №1
        /// ``` http
        /// POST /api/Argon2Compare
        ///
        /// {
        ///     "input": "hello",
        ///     "params": {
        ///         "encoded_hash": "$argon2i$v=19$m=4096,t=3,p=1$c29tZXNhbHQ$WVDOfucSPAey3UEzzqLtBwRbGS83pTyIPLXgjhKfgrY",
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {
        ///   "Ok": "Match `hello`."
        /// }
        /// ```
        /// ## №2
        /// ``` http
        /// POST /api/Argon2Compare
        ///
        /// {
        ///     "input": "Привет, Мир!",
        ///     "params": {
        ///         "encoded_hash": "$argon2id$v=19$m=8096,t=6,p=1$0L3QvtCy0LDRjyDRgdC+0LvRjA$60FAt47RxPzXNsG3PN9VW6JENx/1OXHlOCPkEa7vvWB1HQ",
        ///     }
        /// }
        /// ```
        /// ```http
        /// {
        ///   "Ok": "Match `Привет, Мир!`."
        /// }
        /// ```
        /// ## №3
        /// ``` http
        /// POST /api/Argon2Compare
        ///
        /// {
        ///     "input": "error",
        ///     "params": {
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 400 Bad Request
        /// {
        ///   "Err": "Missing field `encoded_hash`"
        /// }
        /// ```
        pub struct Argon2Compare;
        const NAME: &str = "Argon2compare";
        const DESCRIPTION_EN: &str = "Tests whether the input matches the given Argon2 hash. To test multiple possible passwords, use the 'Fork' operation.";
        const DESCRIPTION_RU: &str = "Проверяет соответствие входных данных заданному хешу Argon2. Чтобы протестировать несколько возможных паролей, используйте операцию `Fork`.";
        const INFO_URL: Option<&str> = Some("https://wikipedia.org/wiki/Argon2");
        pub struct Argon2CompareInfo {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Argon2CompareInfo {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "Argon2CompareInfo",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl Argon2CompareInfo {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub mod argon2_mod {
        use crate::{
            create_info_struct, create_me_daddy, create_tauri_wrapper,
            libs::base64::from_base64, run_operations,
            utils::{to_hex, DataRepresentation, DataRepresentationInput},
            Operation, DOCS_URL,
        };
        use anyhow::{Error, Result};
        use argon2::{Config, ThreadMode, Variant, Version};
        use serde::{Deserialize, Serialize};
        pub fn argon2(request: &str) -> Result<String, String> {
            run_operations(Argon2, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__argon2;
        impl Operation<'_, DeserializeMeDaddy> for Argon2 {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let (params, input) = (request.params, request.input);
                let (salt, variant, mem_cost, time_cost, lanes, hash_length) = (
                    params.salt,
                    params.argon2_type,
                    params.memory,
                    params.iterations,
                    params.parallelism,
                    params.hash_length,
                );
                let config = Config {
                    variant,
                    version: Version::Version13,
                    mem_cost,
                    time_cost,
                    lanes,
                    thread_mode: ThreadMode::Parallel,
                    secret: &[],
                    ad: &[],
                    hash_length,
                };
                let hash = argon2::hash_encoded(
                    input.as_bytes(),
                    salt.as_bytes(),
                    &config,
                )?;
                let output = match params.output_format {
                    OutputFormat::Encoded => hash,
                    format @ (OutputFormat::Hex | OutputFormat::Raw) => {
                        let raw_hash = hash
                            .split('$')
                            .nth(5)
                            .ok_or(Error::msg("Not valid argon2 hash"))?;
                        let data = match from_base64(
                            raw_hash.to_string(),
                            "",
                            DataRepresentationInput::String,
                            false,
                            false,
                        ) {
                            Ok(DataRepresentation::String(data)) => data,
                            _ => {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                        };
                        match format {
                            OutputFormat::Hex => to_hex(data.as_bytes()),
                            OutputFormat::Raw => data,
                            _ => {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                        }
                    }
                };
                Ok(output)
            }
        }
        #[serde(remote = "Variant")]
        enum MyVariant {
            Argon2d = 0,
            Argon2i = 1,
            Argon2id = 2,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            impl<'de> MyVariant {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Variant, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    match _serde::__private::None::<&MyVariant> {
                        _ => {}
                    }
                    match _serde::__private::None {
                        _serde::__private::Some(()) => {
                            let _ = MyVariant::Argon2d;
                        }
                        _ => {}
                    }
                    match _serde::__private::None {
                        _serde::__private::Some(()) => {
                            let _ = MyVariant::Argon2i;
                        }
                        _ => {}
                    }
                    match _serde::__private::None {
                        _serde::__private::Some(()) => {
                            let _ = MyVariant::Argon2id;
                        }
                        _ => {}
                    }
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 3",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Argon2d" => _serde::__private::Ok(__Field::__field0),
                                "Argon2i" => _serde::__private::Ok(__Field::__field1),
                                "Argon2id" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Argon2d" => _serde::__private::Ok(__Field::__field0),
                                b"Argon2i" => _serde::__private::Ok(__Field::__field1),
                                b"Argon2id" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Variant>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Variant;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum Variant",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(Variant::Argon2d)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(Variant::Argon2i)
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(Variant::Argon2id)
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "Argon2d",
                        "Argon2i",
                        "Argon2id",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "MyVariant",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Variant>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[serde(rename_all = "snake_case")]
        enum OutputFormat {
            Encoded,
            Hex,
            Raw,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for OutputFormat {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 3",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "encoded" => _serde::__private::Ok(__Field::__field0),
                                "hex" => _serde::__private::Ok(__Field::__field1),
                                "raw" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"encoded" => _serde::__private::Ok(__Field::__field0),
                                b"hex" => _serde::__private::Ok(__Field::__field1),
                                b"raw" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<OutputFormat>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = OutputFormat;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum OutputFormat",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(OutputFormat::Encoded)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(OutputFormat::Hex)
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(OutputFormat::Raw)
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["encoded", "hex", "raw"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "OutputFormat",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<OutputFormat>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct Params {
            salt: String,
            iterations: u32,
            memory: u32,
            parallelism: u32,
            hash_length: u32,
            #[serde(with = "MyVariant")]
            argon2_type: Variant,
            output_format: OutputFormat,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Params {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "salt" => _serde::__private::Ok(__Field::__field0),
                                "iterations" => _serde::__private::Ok(__Field::__field1),
                                "memory" => _serde::__private::Ok(__Field::__field2),
                                "parallelism" => _serde::__private::Ok(__Field::__field3),
                                "hash_length" => _serde::__private::Ok(__Field::__field4),
                                "argon2_type" => _serde::__private::Ok(__Field::__field5),
                                "output_format" => _serde::__private::Ok(__Field::__field6),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"salt" => _serde::__private::Ok(__Field::__field0),
                                b"iterations" => _serde::__private::Ok(__Field::__field1),
                                b"memory" => _serde::__private::Ok(__Field::__field2),
                                b"parallelism" => _serde::__private::Ok(__Field::__field3),
                                b"hash_length" => _serde::__private::Ok(__Field::__field4),
                                b"argon2_type" => _serde::__private::Ok(__Field::__field5),
                                b"output_format" => _serde::__private::Ok(__Field::__field6),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Params>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Params;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Params",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Params with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                u32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Params with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                u32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct Params with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                u32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct Params with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                u32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct Params with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match {
                                #[doc(hidden)]
                                struct __DeserializeWith<'de> {
                                    value: Variant,
                                    phantom: _serde::__private::PhantomData<Params>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::Deserialize<'de>
                                for __DeserializeWith<'de> {
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::__private::Ok(__DeserializeWith {
                                            value: MyVariant::deserialize(__deserializer)?,
                                            phantom: _serde::__private::PhantomData,
                                            lifetime: _serde::__private::PhantomData,
                                        })
                                    }
                                }
                                _serde::__private::Option::map(
                                    _serde::de::SeqAccess::next_element::<
                                        __DeserializeWith<'de>,
                                    >(&mut __seq)?,
                                    |__wrap| __wrap.value,
                                )
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct Params with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field6 = match _serde::de::SeqAccess::next_element::<
                                OutputFormat,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            6usize,
                                            &"struct Params with 7 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Params {
                                salt: __field0,
                                iterations: __field1,
                                memory: __field2,
                                parallelism: __field3,
                                hash_length: __field4,
                                argon2_type: __field5,
                                output_format: __field6,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<u32> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<u32> = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<u32> = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<u32> = _serde::__private::None;
                            let mut __field5: _serde::__private::Option<Variant> = _serde::__private::None;
                            let mut __field6: _serde::__private::Option<OutputFormat> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("salt"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "iterations",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("memory"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "parallelism",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "hash_length",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "argon2_type",
                                                ),
                                            );
                                        }
                                        __field5 = _serde::__private::Some({
                                            #[doc(hidden)]
                                            struct __DeserializeWith<'de> {
                                                value: Variant,
                                                phantom: _serde::__private::PhantomData<Params>,
                                                lifetime: _serde::__private::PhantomData<&'de ()>,
                                            }
                                            impl<'de> _serde::Deserialize<'de>
                                            for __DeserializeWith<'de> {
                                                fn deserialize<__D>(
                                                    __deserializer: __D,
                                                ) -> _serde::__private::Result<Self, __D::Error>
                                                where
                                                    __D: _serde::Deserializer<'de>,
                                                {
                                                    _serde::__private::Ok(__DeserializeWith {
                                                        value: MyVariant::deserialize(__deserializer)?,
                                                        phantom: _serde::__private::PhantomData,
                                                        lifetime: _serde::__private::PhantomData,
                                                    })
                                                }
                                            }
                                            match _serde::de::MapAccess::next_value::<
                                                __DeserializeWith<'de>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        });
                                    }
                                    __Field::__field6 => {
                                        if _serde::__private::Option::is_some(&__field6) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "output_format",
                                                ),
                                            );
                                        }
                                        __field6 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                OutputFormat,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("salt")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("iterations")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("memory")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("parallelism")?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("hash_length")?
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::missing_field(
                                            "argon2_type",
                                        ),
                                    );
                                }
                            };
                            let __field6 = match __field6 {
                                _serde::__private::Some(__field6) => __field6,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("output_format")?
                                }
                            };
                            _serde::__private::Ok(Params {
                                salt: __field0,
                                iterations: __field1,
                                memory: __field2,
                                parallelism: __field3,
                                hash_length: __field4,
                                argon2_type: __field5,
                                output_format: __field6,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "salt",
                        "iterations",
                        "memory",
                        "parallelism",
                        "hash_length",
                        "argon2_type",
                        "output_format",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Params",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Params>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct DeserializeMeDaddy {
            input: String,
            params: Params,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                "params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                b"params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Params,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Params> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("params"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Params>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("params")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input", "params"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// Argon2 is a key derivation function that was selected as the winner of the Password Hashing Competition in July 2015. It was designed by Alex Biryukov, Daniel Dinu, and Dmitry Khovratovich from the University of Luxembourg.
        /// <br><br/>
        /// For more information go [here](https://wikipedia.org/wiki/Argon2)
        /// <br><br/>
        ///
        /// # How to use
        /// \
        /// Send POST requests to /api/Argon2 with your data using json payload with this structure
        /// ``` json
        /// {
        ///     "input": string,
        ///     "params": {
        ///         "salt": string,
        ///         "iterations": u32,
        ///         "parallelism": u32,
        ///         "hash_length": u32,
        ///         "argon2_type": Argon2Type,
        ///         "output_format": OutputFormat,
        ///         "memory": u32
        ///     }
        /// }
        /// ```
        /// #### where
        ///     - u32 is unsigned 32-bit integer
        ///     - SaltFormat is enum of "utf8", "hex", "base64", "latin1"
        ///     - Argon2Type is enum of "Argon2i", "Argon2d", "Argon2id"
        ///     - OutputFormat is enum of "encoded", "hex", "raw"
        /// <br/><br/>
        ///
        /// ### Server response have two possible formats
        ///
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
        /// ``` json
        /// { "Ok": `some answer` }
        /// ```
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
        /// ``` json
        /// { "Err": `error message` }
        /// ```
        /// # Examples
        /// ## №1
        /// ``` http
        /// POST /api/Argon2
        ///
        /// {
        ///     "input": "hello",
        ///     "params": {
        ///         "salt": "somesalt",
        ///         "iterations": 3,
        ///         "parallelism": 1,
        ///         "hash_length": 32,
        ///         "argon2_type": "Argon2i",
        ///         "output_format": "encoded",
        ///         "memory": 4096
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {
        ///   "Ok": "$argon2i$v=19$m=4096,t=3,p=1$c29tZXNhbHQ$WVDOfucSPAey3UEzzqLtBwRbGS83pTyIPLXgjhKfgrY"
        /// }
        /// ```
        /// ## №2
        /// ``` http
        /// POST /api/Argon2
        ///
        /// {
        ///     "input": "Привет, Мир!",
        ///     "params": {
        ///         "salt": "123456789",
        ///         "iterations": 6,
        ///         "parallelism": 1,
        ///         "hash_length": 34,
        ///         "argon2_type": "Argon2id",
        ///         "output_format": "hex",
        ///         "memory": 8096
        ///     }
        /// }
        /// ```
        /// ```http
        /// {
        ///   "Ok": "hex"
        /// }
        /// ```
        /// ## №3
        /// ``` http
        /// POST /api/Argon2
        ///
        /// {
        ///     "input": "error",
        ///     "params": {
        ///         "salt": "missing iterations parameter",
        ///         "parallelism": 1,
        ///         "hash_length": 34,
        ///         "argon2_type": "Argon2id",
        ///         "output_format": "hex",
        ///         "memory": 8096
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 400 Bad Request
        /// {
        ///   "Err": "Missing field `iterations`"
        /// }
        /// ```
        pub struct Argon2;
        const NAME: &str = "Argon2";
        const DESCRIPTION_EN: &str = "Argon2 is a key derivation function that was selected as the winner of the Password Hashing Competition in July 2015. It was designed by Alex Biryukov, Daniel Dinu, and Dmitry Khovratovich from the University of Luxembourg.<br><br>Enter the password in the input to generate its hash.";
        const DESCRIPTION_RU: &str = "Argon2 – это функция получения ключа, которая была выбрана победителем конкурса хеширования паролей в июле 2015 года. Она была разработана Алексом Бирюковым, Даниэлем Дину и Дмитрием Ховратовичем из Люксембургского университета.<br><br>Введите пароль в ввод для генерации его хэша.";
        const INFO_URL: Option<&str> = Some("https://wikipedia.org/wiki/Argon2");
        pub struct Argon2Info {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Argon2Info {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "Argon2Info",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl Argon2Info {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub mod atbash_cipher_mod {
        use serde::{Deserialize, Serialize};
        use crate::{
            create_info_struct, create_me_daddy, create_tauri_wrapper,
            libs::ciphers::affine_cipher_encode, run_operations,
            utils::SupportedLanguages, Operation, DOCS_URL,
        };
        use anyhow::Result;
        pub fn atbash_cipher(request: &str) -> Result<String, String> {
            run_operations(AtbashCipher, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__atbash_cipher;
        impl Operation<'_, DeserializeMeDaddy> for AtbashCipher {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let (input, lang) = (request.input, request.params.lang);
                match lang {
                    SupportedLanguages::EN => affine_cipher_encode(&input, lang, 25, 25),
                    SupportedLanguages::RU => affine_cipher_encode(&input, lang, 31, 31),
                    SupportedLanguages::RU_WITH_YO => {
                        affine_cipher_encode(&input, lang, 32, 32)
                    }
                }
            }
        }
        struct Params {
            lang: SupportedLanguages,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Params {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "lang" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"lang" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Params>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Params;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Params",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                SupportedLanguages,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Params with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Params { lang: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                SupportedLanguages,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("lang"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SupportedLanguages,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("lang")?
                                }
                            };
                            _serde::__private::Ok(Params { lang: __field0 })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["lang"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Params",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Params>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct DeserializeMeDaddy {
            input: String,
            params: Params,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                "params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                b"params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Params,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Params> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("params"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Params>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("params")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input", "params"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// Atbash is a mono-alphabetic substitution cipher originally used to encode the Hebrew alphabet. It has been modified here for use with the Latin alphabet and Cyrillic.
        /// <br><br/>
        /// For more information go [here](https://wikipedia.org/wiki/Atbash).
        /// <br><br/>
        ///
        /// # How to use
        /// \
        /// Send POST requests to /api/AtbashCipherEncode with your data using json payload with this structure.
        /// ``` json
        /// {
        ///     "input": string,
        ///     "params": {
        ///         "lang": SupportedLanguage,
        ///     }
        /// }
        /// ```
        /// #### where
        ///     - SupportedLanguages is enum of "en", "ru", "ru_with_yo".
        /// <br/><br/>
        ///
        /// ### Server response have two possible formats
        ///
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
        /// ``` json
        /// { "Ok": `some answer` }
        /// ```
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
        /// ``` json
        /// { "Err": `error message` }
        /// ```
        /// # Examples
        /// ## №1
        /// ``` http
        /// POST /api/AtbashCipher
        ///
        /// {
        ///     "input": "hello",
        ///     "params": {
        ///         "lang": "en"
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {
        ///   "Ok": "svool"
        /// }
        /// ```
        /// ## №2
        /// ``` http
        /// POST /api/AtbashCipher
        ///
        /// {
        ///     "input": "Привет!",
        ///     "params": {
        ///         "lang": "ru",
        ///     }
        /// }
        /// ```
        /// ```http
        /// {
        ///   "Ok": "Рпчэън!"
        /// }
        /// ```
        /// ## №3
        /// ``` http
        /// POST /api/AtbashCipher
        ///
        /// {
        ///     "input": "no lang?",
        ///     "params": {
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 400 Bad Request
        /// {
        ///   "Err": "Missing field `lang`"
        /// }
        /// ```
        pub struct AtbashCipher;
        const NAME: &str = "AtbashCipher";
        const DESCRIPTION_EN: &str = "Atbash is a mono-alphabetic substitution cipher originally used to encode the Hebrew alphabet. It has been modified here for use with the Latin alphabet and Cyrillic.";
        const DESCRIPTION_RU: &str = "Атбаш — это моноалфавитный шифр замены, изначально использовавшийся для кодирования еврейского алфавита. Здесь он был изменен для использования с латинским алфавитом и кириллицей";
        const INFO_URL: Option<&str> = Some("https://wikipedia.org/wiki/Atbash");
        pub struct AtbashCipherInfo {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for AtbashCipherInfo {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "AtbashCipherInfo",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl AtbashCipherInfo {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub mod bacon_cipher_decode_mod {
        use crate::{
            create_info_struct, create_me_daddy, create_tauri_wrapper,
            libs::bacon::{
                BaconCipher, SupportedBaconAlphabet, SupportedBaconTranslation,
            },
            run_operations, utils::SupportedLanguages, Operation, DOCS_URL,
        };
        use anyhow::Result;
        use serde::{Deserialize, Serialize};
        use std::mem::swap;
        pub fn bacon_cipher_decode(request: &str) -> Result<String, String> {
            run_operations(BaconCipherDecode, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__bacon_cipher_decode;
        impl Operation<'_, DeserializeMeDaddy> for BaconCipherDecode {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let (
                    input,
                    Params { bacon_alphabet, translation, invert_translation, lang },
                ) = (request.input, request.params);
                let (mut a, mut b) = match translation {
                    SupportedBaconTranslation::ZeroOne => ('0', '1'),
                    SupportedBaconTranslation::AB => ('A', 'B'),
                };
                if invert_translation {
                    swap(&mut a, &mut b);
                }
                let cipher = BaconCipher::new(a, b, translation, bacon_alphabet, lang);
                let output = cipher.decode(&input).join("");
                Ok(output)
            }
        }
        struct DeserializeMeDaddy {
            input: String,
            params: Params,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                "params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                b"params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Params,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Params> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("params"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Params>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("params")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input", "params"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct Params {
            bacon_alphabet: SupportedBaconAlphabet,
            translation: SupportedBaconTranslation,
            invert_translation: bool,
            lang: SupportedLanguages,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Params {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "bacon_alphabet" => _serde::__private::Ok(__Field::__field0),
                                "translation" => _serde::__private::Ok(__Field::__field1),
                                "invert_translation" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                "lang" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"bacon_alphabet" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                b"translation" => _serde::__private::Ok(__Field::__field1),
                                b"invert_translation" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                b"lang" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Params>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Params;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Params",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                SupportedBaconAlphabet,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Params with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                SupportedBaconTranslation,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Params with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                bool,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct Params with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                SupportedLanguages,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct Params with 4 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Params {
                                bacon_alphabet: __field0,
                                translation: __field1,
                                invert_translation: __field2,
                                lang: __field3,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                SupportedBaconAlphabet,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                SupportedBaconTranslation,
                            > = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<bool> = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<
                                SupportedLanguages,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "bacon_alphabet",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SupportedBaconAlphabet,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "translation",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SupportedBaconTranslation,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "invert_translation",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("lang"),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SupportedLanguages,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("bacon_alphabet")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("translation")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("invert_translation")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("lang")?
                                }
                            };
                            _serde::__private::Ok(Params {
                                bacon_alphabet: __field0,
                                translation: __field1,
                                invert_translation: __field2,
                                lang: __field3,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "bacon_alphabet",
                        "translation",
                        "invert_translation",
                        "lang",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Params",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Params>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// Bacon's cipher or the Baconian cipher is a method of steganography devised by Francis Bacon in 1605. A message is concealed in the presentation of text, rather than its content.
        /// <br><br/>
        /// For more information about cipher/hash_function go [here](https://wikipedia.org/wiki/Bacon%27s_cipher)\
        /// For more information about this function go [here](DOCS_URL)
        /// <br><br/>
        ///
        /// # How to use
        /// \
        /// Send POST requests to /api/BaconCipherDecode with your data using json payload with this structure
        /// ``` json
        /// {
        ///     "input": string,
        ///     "params": {
        ///         bacon_alphabet: SupportedBaconAlphabet,
        ///         translation: SupportedBaconTranslation,
        ///         invert_translation: bool,
        ///         lang: SupportedLanguages,
        ///     }
        /// }
        /// ```
        /// #### where
        ///     - SupportedBaconAlphabet is enum of "Standard", "Complete"
        ///     - SupportedBaconTranslation is enum of "0/1", "A/B"
        ///     - SupportedLanguages is enum of "en", "ru", "ru_with_yo"
        /// <br/><br/>
        ///
        /// ### Server response have two possible formats
        ///
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
        /// ``` json
        /// { "Ok": `some answer` }
        /// ```
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
        /// ``` json
        /// { "Err": `error message` }
        /// ```
        /// # Examples
        /// ## №1
        /// ``` http
        /// POST /api/BaconCipherDecode
        ///
        /// {
        ///     "input": "10001 10010 10000 01000 01100 00110",
        ///     "params": {
        ///         bacon_alphabet: "Standard",
        ///         translation: "0/1",
        ///         invert_translation: false,
        ///         lang: "en",
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {
        ///   "Ok": "string"
        /// }
        /// ```
        /// ## №2
        /// ``` http
        /// POST /api/BaconCipherDecode
        ///
        /// {
        ///     "input": "BBAAA BBABB BABAA BABAA BAAAB ABAAB BAAAB ABBBA BABAA BBBAA",
        ///     "params": {
        ///         bacon_alphabet: "Complete",
        ///         translation: "A/B",
        ///         invert_translation: true,
        ///         lang: "en",
        ///     }
        /// }
        /// ```
        /// ```http
        /// {
        ///   "Ok": "helloworld"
        /// }
        /// ```
        /// ## №3
        /// ``` http
        /// POST /api/BaconCipherDecode
        ///
        /// {
        ///     "input": "missing `lang`",
        ///     "params": {
        ///         bacon_alphabet: "Standard",
        ///         translation: "0/1",
        ///         invert_translation: false,
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 400 Bad Request
        /// {
        ///   "Err": "Missing field `lang`."
        /// }
        /// ```
        pub struct BaconCipherDecode;
        const NAME: &str = "Bacon Cipher Decode";
        const DESCRIPTION_EN: &str = "Bacon's cipher or the Baconian cipher is a method of steganography devised by Francis Bacon in 1605. A message is concealed in the presentation of text, rather than its content.";
        const DESCRIPTION_RU: &str = "Шифр Бэкона — это метод стеганографии, разработанный Фрэнсисом Бэконом в 1605 году. Сообщение скрыто в представлении текста, а не в его содержании.";
        const INFO_URL: Option<&str> = Some(
            "https://wikipedia.org/wiki/Bacon%27s_cipher",
        );
        pub struct BaconCipherDecodeInfo {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for BaconCipherDecodeInfo {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "BaconCipherDecodeInfo",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl BaconCipherDecodeInfo {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub mod bacon_cipher_encode_mod {
        use crate::{
            create_info_struct, create_me_daddy, create_tauri_wrapper,
            libs::bacon::{
                BaconCipher, SupportedBaconAlphabet, SupportedBaconTranslation,
            },
            run_operations, utils::SupportedLanguages, Operation, DOCS_URL,
        };
        use anyhow::Result;
        use serde::{Deserialize, Serialize};
        use std::mem::swap;
        pub fn bacon_cipher_encode(request: &str) -> Result<String, String> {
            run_operations(BaconCipherEncode, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__bacon_cipher_encode;
        impl Operation<'_, DeserializeMeDaddy> for BaconCipherEncode {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let (
                    input,
                    Params {
                        bacon_alphabet,
                        translation,
                        keep_extra_character,
                        invert_translation,
                        lang,
                    },
                ) = (request.input, request.params);
                let (mut a, mut b) = match translation {
                    SupportedBaconTranslation::ZeroOne => ('0', '1'),
                    SupportedBaconTranslation::AB => ('A', 'B'),
                };
                if invert_translation {
                    swap(&mut a, &mut b);
                }
                let cipher = BaconCipher::new(a, b, translation, bacon_alphabet, lang);
                let output = cipher.encode(&input);
                let output = if keep_extra_character {
                    output.join("")
                } else {
                    output
                        .iter()
                        .filter(|x| x.len() != 1)
                        .cloned()
                        .collect::<Vec<String>>()
                        .join(" ")
                }
                    .to_uppercase();
                Ok(output)
            }
        }
        struct DeserializeMeDaddy {
            input: String,
            params: Params,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                "params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                b"params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Params,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Params> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("params"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Params>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("params")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input", "params"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct Params {
            bacon_alphabet: SupportedBaconAlphabet,
            translation: SupportedBaconTranslation,
            keep_extra_character: bool,
            invert_translation: bool,
            lang: SupportedLanguages,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Params {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "bacon_alphabet" => _serde::__private::Ok(__Field::__field0),
                                "translation" => _serde::__private::Ok(__Field::__field1),
                                "keep_extra_character" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                "invert_translation" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                "lang" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"bacon_alphabet" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                b"translation" => _serde::__private::Ok(__Field::__field1),
                                b"keep_extra_character" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                b"invert_translation" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                b"lang" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Params>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Params;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Params",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                SupportedBaconAlphabet,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Params with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                SupportedBaconTranslation,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Params with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                bool,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct Params with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                bool,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct Params with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                SupportedLanguages,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct Params with 5 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Params {
                                bacon_alphabet: __field0,
                                translation: __field1,
                                keep_extra_character: __field2,
                                invert_translation: __field3,
                                lang: __field4,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                SupportedBaconAlphabet,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                SupportedBaconTranslation,
                            > = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<bool> = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<bool> = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<
                                SupportedLanguages,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "bacon_alphabet",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SupportedBaconAlphabet,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "translation",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SupportedBaconTranslation,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "keep_extra_character",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "invert_translation",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("lang"),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SupportedLanguages,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("bacon_alphabet")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("translation")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field(
                                        "keep_extra_character",
                                    )?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("invert_translation")?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("lang")?
                                }
                            };
                            _serde::__private::Ok(Params {
                                bacon_alphabet: __field0,
                                translation: __field1,
                                keep_extra_character: __field2,
                                invert_translation: __field3,
                                lang: __field4,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "bacon_alphabet",
                        "translation",
                        "keep_extra_character",
                        "invert_translation",
                        "lang",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Params",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Params>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// Bacon's cipher or the Baconian cipher is a method of steganography devised by Francis Bacon in 1605. A message is concealed in the presentation of text, rather than its content.
        /// <br><br/>
        /// For more information about cipher/hash_function go [here](https://wikipedia.org/wiki/Bacon%27s_cipher)\
        /// For more information about this function go [here](DOCS_URL)
        /// <br><br/>
        ///
        /// # How to use
        /// \
        /// Send POST requests to /api/BaconCipherEncode with your data using json payload with this structure
        /// ``` json
        /// {
        ///     "input": string,
        ///     "params": {
        ///         bacon_alphabet: SupportedBaconAlphabet,
        ///         translation: SupportedBaconTranslation,
        ///         keep_extra_character: bool,
        ///         invert_translation: bool,
        ///         lang: SupportedLanguages,
        ///     }
        /// }
        /// ```
        /// #### where
        ///     - SupportedBaconAlphabet is enum of "Standard", "Complete"
        ///     - SupportedBaconTranslation is enum of "0/1", "A/B"
        ///     - SupportedLanguages is enum of "en", "ru", "ru_with_yo"
        /// <br/><br/>
        ///
        /// ### Server response have two possible formats
        ///
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
        /// ``` json
        /// { "Ok": `some answer` }
        /// ```
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
        /// ``` json
        /// { "Err": `error message` }
        /// ```
        /// # Examples
        /// ## №1
        /// ``` http
        /// POST /api/BaconCipherEncode
        ///
        /// {
        ///     "input": "string",
        ///     "params": {
        ///         bacon_alphabet: "Standard",
        ///         translation: "0/1",
        ///         keep_extra_character: false,
        ///         invert_translation: false,
        ///         lang: "en",
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {
        ///   "Ok": "10001 10010 10000 01000 01100 00110"
        /// }
        /// ```
        /// ## №2
        /// ``` http
        /// POST /api/BaconCipherEncode
        ///
        /// {
        ///     "input": "Hello, World!",
        ///     "params": {
        ///         bacon_alphabet: "Complete",
        ///         translation: "A/B",
        ///         keep_extra_character: true,
        ///         invert_translation: true,
        ///         lang: "en",
        ///     }
        /// }
        /// ```
        /// ```http
        /// {
        ///   "Ok": "BBAAABBABBBABAABABAABAAAB, ABAABBAAABABBBABABAABBBAA!"
        /// }
        /// ```
        /// ## №3
        /// ``` http
        /// POST /api/BaconCipherEncode
        ///
        /// {
        ///     "input": "missing `lang`",
        ///     "params": {
        ///         bacon_alphabet: "Standard",
        ///         translation: "0/1",
        ///         keep_extra_character: true,
        ///         invert_translation: false,
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 400 Bad Request
        /// {
        ///   "Err": "Missing field `lang`."
        /// }
        /// ```
        pub struct BaconCipherEncode;
        const NAME: &str = "Bacon Cipher Encode";
        const DESCRIPTION_EN: &str = "Bacon's cipher or the Baconian cipher is a method of steganography devised by Francis Bacon in 1605. A message is concealed in the presentation of text, rather than its content.";
        const DESCRIPTION_RU: &str = "Шифр Бэкона — это метод стеганографии, разработанный Фрэнсисом Бэконом в 1605 году. Сообщение скрыто в представлении текста, а не в его содержании.";
        const INFO_URL: Option<&str> = Some(
            "https://wikipedia.org/wiki/Bacon%27s_cipher",
        );
        pub struct BaconCipherEncodeInfo {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for BaconCipherEncodeInfo {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "BaconCipherEncodeInfo",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl BaconCipherEncodeInfo {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub mod bcrypt_compare_mod {
        use crate::{
            create_info_struct, create_me_daddy, create_tauri_wrapper, run_operations,
            Operation, DOCS_URL,
        };
        use anyhow::{anyhow, Result};
        use serde::{Deserialize, Serialize};
        pub fn bcrypt_compare(request: &str) -> Result<String, String> {
            run_operations(BcryptCompare, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__bcrypt_compare;
        impl Operation<'_, DeserializeMeDaddy> for BcryptCompare {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let (input, encoded_hash) = (request.input, request.params.encoded_hash);
                let res = bcrypt::verify(input.as_bytes(), &encoded_hash)?;
                match res {
                    true => {
                        Ok({
                            let res = ::alloc::fmt::format(
                                format_args!("Match `{0}`.", input),
                            );
                            res
                        })
                    }
                    false => {
                        Err(
                            ::anyhow::__private::must_use({
                                let error = ::anyhow::__private::format_err(
                                    format_args!("No match."),
                                );
                                error
                            }),
                        )
                    }
                }
            }
        }
        struct Params {
            encoded_hash: String,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Params {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "encoded_hash" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"encoded_hash" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Params>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Params;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Params",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Params with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Params { encoded_hash: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "encoded_hash",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("encoded_hash")?
                                }
                            };
                            _serde::__private::Ok(Params { encoded_hash: __field0 })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["encoded_hash"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Params",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Params>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct DeserializeMeDaddy {
            input: String,
            params: Params,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                "params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                b"params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Params,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Params> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("params"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Params>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("params")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input", "params"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// Tests whether the input matches the given bcrypt hash. To test multiple possible passwords, use the 'Fork' operation.
        /// <br><br/>
        /// For more information about cipher/hash_function go [here](https://wikipedia.org/wiki/Bcrypt)\
        /// For more information about this function go [here](DOCS_URL)
        /// <br><br/>
        ///
        /// # How to use
        /// \
        /// Send POST requests to /api/BcryptCompare with your data using json payload with this structure
        /// ``` json
        /// {
        ///     "input": string,
        ///     "params": {
        ///         "encoded_hash": String
        ///     }
        /// }
        /// ```
        /// <br/><br/>
        ///
        /// ### Server response have two possible formats
        ///
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
        /// ``` json
        /// { "Ok": `some answer` }
        /// ```
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
        /// ``` json
        /// { "Err": `error message` }
        /// ```
        /// # Examples
        /// ## №1
        /// ``` http
        /// POST /api/BcryptCompare
        ///
        /// {
        ///     "input": "hello",
        ///     "params": {
        ///         "encoded_hash": "$2b$12$mLDUe/nTaPt06W2ai4YrVeCiPK7/L1Dhj7FipakSCnKIDsgqbvPgm"
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {
        ///   "Ok": "Match `hello`."
        /// }
        /// ```
        /// ## №2
        /// ``` http
        /// POST /api/BcryptCompare
        ///
        /// {
        ///     "input": "Привет, Мир!",
        ///     "params": {
        ///         "encoded_hash": "$2x$04$hC6BHE9hPEQZExczLDTxBOgq48yNMI7HC5bmE0HiP/iGxtMpwryh6"
        ///     }
        /// }
        /// ```
        /// ```http
        /// {
        ///   "Ok": "Match `Привет, Мир!`."
        /// }
        /// ```
        /// ## №3
        /// ``` http
        /// POST /api/BcryptCompare
        ///
        /// {
        ///     "input": "missing encoded_hash",
        ///     "params": {
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 400 Bad Request
        /// {
        ///   "Err": "Missing field `encoded_hash`."
        /// }
        /// ```
        pub struct BcryptCompare;
        const NAME: &str = "BcryptCompare";
        const DESCRIPTION_EN: &str = "Tests whether the input matches the given bcrypt hash. To test multiple possible passwords, use the 'Fork' operation.";
        const DESCRIPTION_RU: &str = "Проверяет, соответствует ли ввод заданному хешу bcrypt. Чтобы протестировать несколько возможных паролей, используйте операцию `Fork`.";
        const INFO_URL: Option<&str> = Some("https://wikipedia.org/wiki/Bcrypt");
        pub struct BcryptCompareInfo {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for BcryptCompareInfo {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "BcryptCompareInfo",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl BcryptCompareInfo {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub mod bcrypt_mod {
        use crate::{
            create_info_struct, create_me_daddy, create_tauri_wrapper, run_operations,
            Operation, DOCS_URL,
        };
        use anyhow::Result;
        use bcrypt::Version;
        use serde::{Deserialize, Serialize};
        use serde_valid::Validate;
        pub fn bcrypt(request: &str) -> Result<String, String> {
            run_operations(Bcrypt, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__bcrypt;
        impl Operation<'_, DeserializeMeDaddy> for Bcrypt {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let (input, Params { rounds, version }) = (
                    request.input,
                    request.params,
                );
                let res = bcrypt::hash_with_result(input.as_bytes(), rounds)?;
                Ok(res.format_for_version(version))
            }
        }
        #[serde(remote = "Version")]
        pub enum MyVersion {
            #[serde(rename = "2a")]
            TwoA,
            #[serde(rename = "2x")]
            TwoX,
            #[serde(rename = "2y")]
            TwoY,
            #[serde(rename = "2b")]
            TwoB,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            impl<'de> MyVersion {
                pub fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Version, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    match _serde::__private::None::<&MyVersion> {
                        _ => {}
                    }
                    match _serde::__private::None {
                        _serde::__private::Some(()) => {
                            let _ = MyVersion::TwoA;
                        }
                        _ => {}
                    }
                    match _serde::__private::None {
                        _serde::__private::Some(()) => {
                            let _ = MyVersion::TwoX;
                        }
                        _ => {}
                    }
                    match _serde::__private::None {
                        _serde::__private::Some(()) => {
                            let _ = MyVersion::TwoY;
                        }
                        _ => {}
                    }
                    match _serde::__private::None {
                        _serde::__private::Some(()) => {
                            let _ = MyVersion::TwoB;
                        }
                        _ => {}
                    }
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 4",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "2a" => _serde::__private::Ok(__Field::__field0),
                                "2x" => _serde::__private::Ok(__Field::__field1),
                                "2y" => _serde::__private::Ok(__Field::__field2),
                                "2b" => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"2a" => _serde::__private::Ok(__Field::__field0),
                                b"2x" => _serde::__private::Ok(__Field::__field1),
                                b"2y" => _serde::__private::Ok(__Field::__field2),
                                b"2b" => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Version>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Version;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum Version",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(Version::TwoA)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(Version::TwoX)
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(Version::TwoY)
                                }
                                (__Field::__field3, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(Version::TwoB)
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["2a", "2x", "2y", "2b"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "MyVersion",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Version>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct Params {
            #[validate(maximum = 31)]
            #[validate(minimum = 4)]
            rounds: u32,
            #[serde(with = "MyVersion")]
            version: Version,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Params {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "rounds" => _serde::__private::Ok(__Field::__field0),
                                "version" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"rounds" => _serde::__private::Ok(__Field::__field0),
                                b"version" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Params>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Params;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Params",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                u32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Params with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match {
                                #[doc(hidden)]
                                struct __DeserializeWith<'de> {
                                    value: Version,
                                    phantom: _serde::__private::PhantomData<Params>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::Deserialize<'de>
                                for __DeserializeWith<'de> {
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::__private::Ok(__DeserializeWith {
                                            value: MyVersion::deserialize(__deserializer)?,
                                            phantom: _serde::__private::PhantomData,
                                            lifetime: _serde::__private::PhantomData,
                                        })
                                    }
                                }
                                _serde::__private::Option::map(
                                    _serde::de::SeqAccess::next_element::<
                                        __DeserializeWith<'de>,
                                    >(&mut __seq)?,
                                    |__wrap| __wrap.value,
                                )
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Params with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Params {
                                rounds: __field0,
                                version: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<u32> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Version> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("rounds"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "version",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some({
                                            #[doc(hidden)]
                                            struct __DeserializeWith<'de> {
                                                value: Version,
                                                phantom: _serde::__private::PhantomData<Params>,
                                                lifetime: _serde::__private::PhantomData<&'de ()>,
                                            }
                                            impl<'de> _serde::Deserialize<'de>
                                            for __DeserializeWith<'de> {
                                                fn deserialize<__D>(
                                                    __deserializer: __D,
                                                ) -> _serde::__private::Result<Self, __D::Error>
                                                where
                                                    __D: _serde::Deserializer<'de>,
                                                {
                                                    _serde::__private::Ok(__DeserializeWith {
                                                        value: MyVersion::deserialize(__deserializer)?,
                                                        phantom: _serde::__private::PhantomData,
                                                        lifetime: _serde::__private::PhantomData,
                                                    })
                                                }
                                            }
                                            match _serde::de::MapAccess::next_value::<
                                                __DeserializeWith<'de>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        });
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("rounds")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::missing_field("version"),
                                    );
                                }
                            };
                            _serde::__private::Ok(Params {
                                rounds: __field0,
                                version: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["rounds", "version"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Params",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Params>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl ::serde_valid::Validate for Params {
            fn validate(
                &self,
            ) -> std::result::Result<(), ::serde_valid::validation::Errors> {
                let mut __rule_vec_errors = ::serde_valid::validation::VecErrors::new();
                let mut __property_vec_errors_map = ::serde_valid::validation::PropertyVecErrorsMap::new();
                let rounds = &self.rounds;
                if let Err(__composited_error_params)
                    = ::serde_valid::validation::ValidateCompositedMaximum::validate_composited_maximum(
                        rounds,
                        31,
                    ) {
                    use ::serde_valid::validation::{IntoError, ToDefaultMessage};
                    __property_vec_errors_map
                        .entry("rounds".to_string())
                        .or_default()
                        .push(
                            __composited_error_params
                                .into_error_by(::serde_valid::validation::CustomMessage {
                                    message_fn: ::serde_valid::validation::ToDefaultMessage::to_default_message,
                                }),
                        );
                }
                if let Err(__composited_error_params)
                    = ::serde_valid::validation::ValidateCompositedMinimum::validate_composited_minimum(
                        rounds,
                        4,
                    ) {
                    use ::serde_valid::validation::{IntoError, ToDefaultMessage};
                    __property_vec_errors_map
                        .entry("rounds".to_string())
                        .or_default()
                        .push(
                            __composited_error_params
                                .into_error_by(::serde_valid::validation::CustomMessage {
                                    message_fn: ::serde_valid::validation::ToDefaultMessage::to_default_message,
                                }),
                        );
                }
                if __rule_vec_errors.is_empty() && __property_vec_errors_map.is_empty() {
                    Ok(())
                } else {
                    Err(
                        ::serde_valid::validation::Errors::Object(
                            ::serde_valid::validation::ObjectErrors::new(
                                __rule_vec_errors,
                                __property_vec_errors_map
                                    .into_iter()
                                    .map(|(field, errors)| {
                                        let mut __field_items_errors = ::alloc::vec::Vec::new();
                                        let mut __field_properties_errors = None;
                                        let mut __field_errors: ::serde_valid::validation::VecErrors = errors
                                            .into_iter()
                                            .filter_map(|error| match error {
                                                ::serde_valid::validation::Error::Items(__array_errors) => {
                                                    __field_items_errors.push(__array_errors);
                                                    None
                                                }
                                                ::serde_valid::validation::Error::Properties(
                                                    __object_errors,
                                                ) => {
                                                    __field_properties_errors = Some(__object_errors);
                                                    None
                                                }
                                                _ => Some(error),
                                            })
                                            .collect();
                                        if let Some(__object_errors) = __field_properties_errors {
                                            __field_errors.extend(__object_errors.errors);
                                            (
                                                field,
                                                ::serde_valid::validation::Errors::Object(
                                                    ::serde_valid::validation::ObjectErrors::new(
                                                        __field_errors,
                                                        __object_errors.properties,
                                                    ),
                                                ),
                                            )
                                        } else if !__field_items_errors.is_empty() {
                                            let __array_errors = __field_items_errors
                                                .into_iter()
                                                .reduce(|a, b| a.merge(b))
                                                .unwrap();
                                            __field_errors.extend(__array_errors.errors);
                                            (
                                                field,
                                                ::serde_valid::validation::Errors::Array(
                                                    ::serde_valid::validation::ArrayErrors::new(
                                                        __field_errors,
                                                        __array_errors.items,
                                                    ),
                                                ),
                                            )
                                        } else {
                                            (
                                                field,
                                                ::serde_valid::validation::Errors::NewType(__field_errors),
                                            )
                                        }
                                    })
                                    .collect(),
                            ),
                        ),
                    )
                }
            }
        }
        struct DeserializeMeDaddy {
            input: String,
            params: Params,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                "params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                b"params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Params,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Params> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("params"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Params>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("params")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input", "params"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// bcrypt is a password hashing function designed by Niels Provos and David Mazières, based on the Blowfish cipher, and presented at USENIX in 1999. Besides incorporating a salt to protect against rainbow table attacks, bcrypt is an adaptive function: over time, the iteration count (rounds) can be increased to make it slower, so it remains resistant to brute-force search attacks even with increasing computation power.
        /// <br><br/>
        /// For more information about cipher/hash_function go [here](https://wikipedia.org/wiki/Bcrypt)
        /// For more information about this function go [here](DOCS_URL)
        /// <br><br/>
        ///
        /// # How to use
        /// \
        /// Send POST requests to /api/Bcrypt with your data using json payload with this structure
        /// ``` json
        /// {
        ///     "input": string,
        ///     "params": {
        ///         "rounds": i31,
        ///         "version": Version
        ///     }
        /// }
        /// ```
        /// #### where
        ///     - i31 is signed digit between 4 and 31
        ///     - Version is enum of "2a", "2x", "2y", "2b"
        /// <br/><br/>
        ///
        /// ### Server response have two possible formats
        ///
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
        /// ``` json
        /// { "Ok": `some answer` }
        /// ```
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
        /// ``` json
        /// { "Err": `error message` }
        /// ```
        /// # Examples
        /// ## №1
        /// ``` http
        /// POST /api/Bcrypt
        ///
        /// {
        ///     "input": "hello",
        ///     "params": {
        ///         "rounds": 12,
        ///         "version": "2b"
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {
        ///   "Ok": "$2b$12$mLDUe/nTaPt06W2ai4YrVeCiPK7/L1Dhj7FipakSCnKIDsgqbvPgm"
        /// }
        /// ```
        /// ## №2
        /// ``` http
        /// POST /api/Bcrypt
        ///
        /// {
        ///     "input": "Привет, Мир!",
        ///     "params": {
        ///         "rounds": 4,
        ///         "version": "2x"
        ///     }
        /// }
        /// ```
        /// ```http
        /// {
        ///   "Ok": "$2x$04$hC6BHE9hPEQZExczLDTxBOgq48yNMI7HC5bmE0HiP/iGxtMpwryh6"
        /// }
        /// ```
        /// ## №3
        /// ``` http
        /// POST /api/Bcrypt
        ///
        /// {
        ///     "input": "missing version",
        ///     "params": {
        ///         "rounds": 4
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 400 Bad Request
        /// {
        ///   "Err": "Missing field `version`."
        /// }
        /// ```
        struct Bcrypt;
        const NAME: &str = "Bcrypt";
        const DESCRIPTION_EN: &str = "bcrypt is a password hashing function designed by Niels Provos and David Mazières, based on the Blowfish cipher, and presented at USENIX in 1999. Besides incorporating a salt to protect against rainbow table attacks, bcrypt is an adaptive function: over time, the iteration count (rounds) can be increased to make it slower, so it remains resistant to brute-force search attacks even with increasing computation power.";
        const DESCRIPTION_RU: &str = "bcrypt — это функция хеширования паролей, разработанная Нильсом Провосом и Давидом Мазьером на основе шифра Blowfish и представленная на USENIX в 1999 году. Помимо включения соли для защиты от RainbowTableAttack, bcrypt является адаптивной функцией: со временем количество итераций (раундов) может быть увеличено, чтобы сделать его медленнее, поэтому он остается устойчивым к поисковым атакам методом грубой силы даже при увеличении вычислительной мощности.";
        const INFO_URL: Option<&str> = Some("https://wikipedia.org/wiki/Bcrypt");
        pub struct BcryptInfo {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for BcryptInfo {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "BcryptInfo",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl BcryptInfo {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub mod bcrypt_parse_mod {
        use crate::{
            create_info_struct, create_tauri_wrapper, run_operations, Operation, DOCS_URL,
        };
        use anyhow::{bail, Result};
        use bcrypt::BcryptError;
        use serde::{Deserialize, Serialize};
        use serde_valid::Validate;
        pub fn bcrypt_parse(request: &str) -> Result<String, String> {
            run_operations(BcryptParse, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__bcrypt_parse;
        impl Operation<'_, DeserializeMeDaddy> for BcryptParse {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let hash = request.hash;
                let mut parts = HashParts {
                    cost: 0,
                    salt: "".to_string(),
                    hash: "".to_string(),
                };
                let raw_parts: Vec<_> = hash
                    .split('$')
                    .filter(|s| !s.is_empty())
                    .collect();
                if raw_parts.len() != 3 {
                    return ::anyhow::__private::Err({
                        use ::anyhow::__private::kind::*;
                        let error = match BcryptError::InvalidHash(hash) {
                            error => (&error).anyhow_kind().new(error),
                        };
                        error
                    });
                }
                if raw_parts[0] != "2y" && raw_parts[0] != "2b" && raw_parts[0] != "2a"
                    && raw_parts[0] != "2x"
                {
                    return ::anyhow::__private::Err({
                        use ::anyhow::__private::kind::*;
                        let error = match BcryptError::InvalidPrefix(
                            raw_parts[0].to_string(),
                        ) {
                            error => (&error).anyhow_kind().new(error),
                        };
                        error
                    });
                }
                if let Ok(c) = raw_parts[1].parse::<u32>() {
                    parts.cost = c;
                } else {
                    return ::anyhow::__private::Err({
                        use ::anyhow::__private::kind::*;
                        let error = match BcryptError::InvalidCost(
                            raw_parts[1].to_string(),
                        ) {
                            error => (&error).anyhow_kind().new(error),
                        };
                        error
                    });
                }
                if raw_parts[2].len() == 53 && raw_parts[2].is_char_boundary(22) {
                    parts.salt = raw_parts[2][..22].chars().collect();
                    parts.hash = raw_parts[2][22..].chars().collect();
                } else {
                    return ::anyhow::__private::Err({
                        use ::anyhow::__private::kind::*;
                        let error = match BcryptError::InvalidHash(hash) {
                            error => (&error).anyhow_kind().new(error),
                        };
                        error
                    });
                }
                let result = {
                    let res = ::alloc::fmt::format(
                        format_args!("{0} {1} {2}", parts.cost, parts.salt, parts.hash),
                    );
                    res
                };
                Ok(result)
            }
        }
        struct DeserializeMeDaddy {
            hash: String,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "hash" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"hash" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                hash: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("hash"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("hash")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                hash: __field0,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["hash"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub struct HashParts {
            #[validate(maximum = 31)]
            #[validate(minimum = 4)]
            cost: u32,
            salt: String,
            hash: String,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for HashParts {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "HashParts",
                        false as usize + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "cost",
                        &self.cost,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "salt",
                        &self.salt,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "hash",
                        &self.hash,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl ::serde_valid::Validate for HashParts {
            fn validate(
                &self,
            ) -> std::result::Result<(), ::serde_valid::validation::Errors> {
                let mut __rule_vec_errors = ::serde_valid::validation::VecErrors::new();
                let mut __property_vec_errors_map = ::serde_valid::validation::PropertyVecErrorsMap::new();
                let cost = &self.cost;
                if let Err(__composited_error_params)
                    = ::serde_valid::validation::ValidateCompositedMaximum::validate_composited_maximum(
                        cost,
                        31,
                    ) {
                    use ::serde_valid::validation::{IntoError, ToDefaultMessage};
                    __property_vec_errors_map
                        .entry("cost".to_string())
                        .or_default()
                        .push(
                            __composited_error_params
                                .into_error_by(::serde_valid::validation::CustomMessage {
                                    message_fn: ::serde_valid::validation::ToDefaultMessage::to_default_message,
                                }),
                        );
                }
                if let Err(__composited_error_params)
                    = ::serde_valid::validation::ValidateCompositedMinimum::validate_composited_minimum(
                        cost,
                        4,
                    ) {
                    use ::serde_valid::validation::{IntoError, ToDefaultMessage};
                    __property_vec_errors_map
                        .entry("cost".to_string())
                        .or_default()
                        .push(
                            __composited_error_params
                                .into_error_by(::serde_valid::validation::CustomMessage {
                                    message_fn: ::serde_valid::validation::ToDefaultMessage::to_default_message,
                                }),
                        );
                }
                if __rule_vec_errors.is_empty() && __property_vec_errors_map.is_empty() {
                    Ok(())
                } else {
                    Err(
                        ::serde_valid::validation::Errors::Object(
                            ::serde_valid::validation::ObjectErrors::new(
                                __rule_vec_errors,
                                __property_vec_errors_map
                                    .into_iter()
                                    .map(|(field, errors)| {
                                        let mut __field_items_errors = ::alloc::vec::Vec::new();
                                        let mut __field_properties_errors = None;
                                        let mut __field_errors: ::serde_valid::validation::VecErrors = errors
                                            .into_iter()
                                            .filter_map(|error| match error {
                                                ::serde_valid::validation::Error::Items(__array_errors) => {
                                                    __field_items_errors.push(__array_errors);
                                                    None
                                                }
                                                ::serde_valid::validation::Error::Properties(
                                                    __object_errors,
                                                ) => {
                                                    __field_properties_errors = Some(__object_errors);
                                                    None
                                                }
                                                _ => Some(error),
                                            })
                                            .collect();
                                        if let Some(__object_errors) = __field_properties_errors {
                                            __field_errors.extend(__object_errors.errors);
                                            (
                                                field,
                                                ::serde_valid::validation::Errors::Object(
                                                    ::serde_valid::validation::ObjectErrors::new(
                                                        __field_errors,
                                                        __object_errors.properties,
                                                    ),
                                                ),
                                            )
                                        } else if !__field_items_errors.is_empty() {
                                            let __array_errors = __field_items_errors
                                                .into_iter()
                                                .reduce(|a, b| a.merge(b))
                                                .unwrap();
                                            __field_errors.extend(__array_errors.errors);
                                            (
                                                field,
                                                ::serde_valid::validation::Errors::Array(
                                                    ::serde_valid::validation::ArrayErrors::new(
                                                        __field_errors,
                                                        __array_errors.items,
                                                    ),
                                                ),
                                            )
                                        } else {
                                            (
                                                field,
                                                ::serde_valid::validation::Errors::NewType(__field_errors),
                                            )
                                        }
                                    })
                                    .collect(),
                            ),
                        ),
                    )
                }
            }
        }
        /// Parses a bcrypt hash to determine the number of rounds used, the salt, and the password hash.
        /// <br><br/>
        /// For more information about cipher/hash_function go [here](https://wikipedia.org/wiki/Bcrypt)
        /// For more information about this function go [here](DOCS_URL)
        /// <br><br/>
        ///
        /// # How to use
        /// \
        /// Send POST requests to /api/BcryptParse with your data using json payload with this structure
        /// ``` json
        /// {
        ///     "hash": string,
        /// }
        /// ```
        /// <br/><br/>
        ///
        /// ## Server response have two possible formats
        ///
        /// ### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
        /// ``` json
        /// {
        ///     "Ok": {
        ///         "cost": i31,
        ///         "salt": string,
        ///         "hash": string
        ///     }
        /// }
        /// ```
        /// #### where
        ///     - i31 is signed digit between 4 and 31
        /// ### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
        /// ``` json
        /// { "Err": `error message` }
        /// ```
        /// # Examples
        /// ## №1
        /// ``` http
        /// POST /api/BcryptParse
        ///
        /// {
        ///     "hash": "$2x$04$hC6BHE9hPEQZExczLDTxBOgq48yNMI7HC5bmE0HiP/iGxtMpwryh6"
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {
        ///   "Ok": {
        ///     "cost": 4,
        ///     "salt": "hC6BHE9hPEQZExczLDTxBO",
        ///     "hash": "gq48yNMI7HC5bmE0HiP/iGxtMpwryh6"
        ///    }
        /// }
        /// ```
        /// ## №2
        /// ``` http
        /// POST /api/BcryptParse
        ///
        /// {
        ///     "hash": "$2b$12$mLDUe/nTaPt06W2ai4YrVeCiPK7/L1Dhj7FipakSCnKIDsgqbvPgm"
        /// }
        /// ```
        /// ```http
        /// {
        ///   "Ok": {
        ///     "cost": 12,
        ///     "salt": "mLDUe/nTaPt06W2ai4YrVe",
        ///     "hash": "CiPK7/L1Dhj7FipakSCnKIDsgqbvPgm"
        ///    }
        /// }
        /// ```
        /// ## №3
        /// ``` http
        /// POST /api/BcryptParse
        ///
        /// {
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 400 Bad Request
        /// {
        ///   "Err": "Missing field `hash`."
        /// }
        /// ```
        pub struct BcryptParse;
        const NAME: &str = "BcryptParse";
        const DESCRIPTION_EN: &str = "Parses a bcrypt hash to determine the number of rounds used, the salt, and the password hash.";
        const DESCRIPTION_RU: &str = "Анализирует хэш bcrypt для определения количества использованных раундов, соли и хэша пароля.";
        const INFO_URL: Option<&str> = Some("https://wikipedia.org/wiki/Bcrypt");
        pub struct BcryptParseInfo {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for BcryptParseInfo {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "BcryptParseInfo",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl BcryptParseInfo {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub mod bifid_cipher_encode_mod {
        use itertools::Itertools;
        use serde::{Deserialize, Serialize};
        use std::collections::HashMap;
        use crate::{
            create_info_struct, create_me_daddy, create_tauri_wrapper,
            libs::ciphers::gen_polybius_square, regex_check, run_operations,
            traits::CharTrait, utils::{get_alphabet, SupportedLanguages},
            Operation, DOCS_URL,
        };
        use anyhow::{bail, Result};
        pub fn bifid_cipher_encode(request: &str) -> Result<String, String> {
            run_operations(BifidCipherEncode, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__bifid_cipher_encode;
        impl Operation<'_, DeserializeMeDaddy> for BifidCipherEncode {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let (input, lang, keyword) = (
                    request.input,
                    request.params.lang,
                    request.params.keyword,
                );
                let keyword_str = match lang {
                    SupportedLanguages::EN => keyword.to_uppercase().replace('J', "I"),
                    SupportedLanguages::RU | SupportedLanguages::RU_WITH_YO => {
                        keyword.to_uppercase()
                    }
                };
                let keyword: String = keyword_str.chars().dedup().collect();
                let (_, _, _, _, _, reg) = get_alphabet(&lang);
                if !{
                    let regex = regex::Regex::new(reg).unwrap();
                    regex.is_match(&keyword_str)
                } && keyword.is_empty()
                {
                    return ::anyhow::__private::Err({
                        let error = ::anyhow::__private::format_err(
                            format_args!(
                                "The key must consist only of your alphabets characters",
                            ),
                        );
                        error
                    });
                }
                let (input, size) = match lang {
                    SupportedLanguages::EN => {
                        (input.replace('J', "I").replace('j', "i"), 5)
                    }
                    SupportedLanguages::RU | SupportedLanguages::RU_WITH_YO => (input, 6),
                };
                let mut x_cord: Vec<usize> = Vec::new();
                let mut y_cord: Vec<usize> = Vec::new();
                let mut other: HashMap<usize, char> = HashMap::new();
                let mut case: Vec<bool> = Vec::new();
                let mut output = String::new();
                let polybius = gen_polybius_square(&lang, &keyword_str);
                for (i, letter) in input.chars().enumerate() {
                    case.push(letter.is_lowercase());
                    let idx = polybius
                        .iter()
                        .position(|&x| x == letter.to_upper_case())
                        .unwrap_or(usize::MAX);
                    if idx == usize::MAX {
                        other.insert(i, letter);
                        continue;
                    }
                    x_cord.push((idx as f64 / size as f64).ceil() as usize - 1);
                    y_cord.push(idx % size);
                }
                x_cord.extend(y_cord);
                let mut kludge = false;
                let mut i = 0;
                let mut case_idx = 0;
                let input_len = input.chars().count();
                while output.chars().count() != input_len {
                    if let Some(ch) = other.get(&output.chars().count()) {
                        output
                            .push(
                                match case[case_idx] {
                                    true => ch.to_lower_case(),
                                    false => *ch,
                                },
                            );
                        case_idx += 1;
                        continue;
                    }
                    if kludge {
                        kludge = !kludge;
                        continue;
                    }
                    let letter = polybius[x_cord[i] * size + x_cord[i + 1]];
                    output
                        .push({
                            let out = match case[case_idx] {
                                true => letter.to_lower_case(),
                                false => letter,
                            };
                            case_idx += 1;
                            out
                        });
                    kludge = !kludge;
                    i += 2;
                }
                Ok(output)
            }
        }
        struct Params {
            lang: SupportedLanguages,
            keyword: String,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Params {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "lang" => _serde::__private::Ok(__Field::__field0),
                                "keyword" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"lang" => _serde::__private::Ok(__Field::__field0),
                                b"keyword" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Params>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Params;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Params",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                SupportedLanguages,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Params with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Params with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Params {
                                lang: __field0,
                                keyword: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                SupportedLanguages,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("lang"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SupportedLanguages,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "keyword",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("lang")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("keyword")?
                                }
                            };
                            _serde::__private::Ok(Params {
                                lang: __field0,
                                keyword: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["lang", "keyword"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Params",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Params>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct DeserializeMeDaddy {
            input: String,
            params: Params,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                "params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                b"params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Params,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Params> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("params"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Params>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("params")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input", "params"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// The Bifid cipher is a cipher which uses a Polybius square in conjunction with transposition, which can be fairly difficult to decipher without knowing the alphabet keyword.
        /// <br><br/>
        /// For more information about cipher/hash_function go [here](https://wikipedia.org/wiki/Bifid_cipher)
        /// For more information about this function go [here](DOCS_URL)
        /// <br><br/>
        ///
        /// # How to use
        /// \
        /// Send POST requests to /api/BifidCipherEncode with your data using json payload with this structure
        /// ``` json
        /// {
        ///     "input": string,
        ///     "params": {
        ///         "lang": SupportedLanguages,
        ///         "keyword": string
        ///     }
        /// }
        /// ```
        /// #### where
        ///     - SupportedLanguages is enum of "en", "ru", "ru_with_yo".
        /// <br/><br/>
        ///
        /// ## Server response have two possible formats
        ///
        /// ### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
        /// ``` json
        /// { "Ok": `some answer` }
        /// ```
        /// ### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
        /// ``` json
        /// { "Err": `error message` }
        /// ```
        /// # Examples
        /// ## №1
        /// ``` http
        /// POST /api/BifidCipherEncode
        ///
        /// {
        ///     "input": "hello",
        ///     "params": {
        ///         "lang": "en",
        ///         "keyword": "key"
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {
        ///   "Ok": "cmodh"
        /// }
        /// ```
        /// ## №2
        /// ``` http
        /// POST /api/BifidCipherEncode
        ///
        /// {
        ///     "input": "тестовое сообщение на русском",
        ///     "params": {
        ///         "lang": "ru",
        ///         "keyword": "ключ"
        ///     }
        /// }
        /// ```
        /// ```http
        /// {
        ///   "Ok": "ртйксйцк еатслсм,э оя чънрчкю"
        /// }
        /// ```
        /// ## №3
        /// ``` http
        /// POST /api/BifidCipherEncode
        ///
        /// {
        ///     "input": "тестовое сообщение на русском",
        ///     "params": {
        ///         "lang": "ru",
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 400 Bad Request
        /// {
        ///   "Err": "Missing field `keyword`."
        /// }
        /// ```
        pub struct BifidCipherEncode;
        const NAME: &str = "BifidCipherEncode";
        const DESCRIPTION_EN: &str = "The Bifid cipher is a cipher which uses a Polybius square in conjunction with transposition, which can be fairly difficult to decipher without knowing the alphabet keyword.";
        const DESCRIPTION_RU: &str = "Шифр Бифида - это шифр, в котором используется квадрат Полибия в сочетании с транспозицией, которую довольно сложно расшифровать, не зная ключевого слова алфавита.";
        const INFO_URL: Option<&str> = Some("https://wikipedia.org/wiki/Bifid_cipher");
        pub struct BifidCipherEncodeInfo {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for BifidCipherEncodeInfo {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "BifidCipherEncodeInfo",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl BifidCipherEncodeInfo {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub mod blake2b_mod {
        use crate::{
            create_info_struct, create_me_daddy, create_tauri_wrapper,
            libs::base64::to_base64, run_operations,
            utils::{convert_to_byte_array, to_hex, SupportedFormats},
            Operation, DOCS_URL,
        };
        use anyhow::{bail, Result};
        use blake2::{
            digest::{Update, VariableOutput},
            VarBlake2b,
        };
        use serde::{Deserialize, Serialize};
        pub fn blake2b(request: &str) -> Result<String, String> {
            run_operations(Blake2b, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__blake2b;
        impl Operation<'_, DeserializeMeDaddy> for Blake2b {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let (input, size, key, key_format, output_format) = (
                    request.input,
                    request.params.size,
                    request.params.key,
                    request.params.key_format,
                    request.params.output_format,
                );
                let key = match key {
                    None => Vec::new(),
                    Some(key) => {
                        match key_format {
                            None => {
                                return ::anyhow::__private::Err({
                                    let error = ::anyhow::__private::format_err(
                                        format_args!("Key format argument must be set."),
                                    );
                                    error
                                });
                            }
                            Some(key_format) => convert_to_byte_array(&key, &key_format)?,
                        }
                    }
                };
                let mut hasher = VarBlake2b::new_keyed(
                    &key,
                    match size {
                        SupportedBlake2bSize::Blake2b128 => 16,
                        SupportedBlake2bSize::Blake2b160 => 20,
                        SupportedBlake2bSize::Blake2b256 => 32,
                        SupportedBlake2bSize::Blake2b384 => 48,
                        SupportedBlake2bSize::Blake2b512 => 64,
                    },
                );
                hasher.update(input.as_bytes());
                let res = hasher.finalize_boxed();
                Ok(
                    match output_format {
                        SupportedOutputFormat::Hex => to_hex(&res),
                        SupportedOutputFormat::Base64 => to_base64(&res, None)?,
                        SupportedOutputFormat::Uint8Array => {
                            String::from_utf8_lossy(&res).to_string()
                        }
                    },
                )
            }
        }
        enum SupportedBlake2bSize {
            #[serde(rename = "128")]
            Blake2b128,
            #[serde(rename = "160")]
            Blake2b160,
            #[serde(rename = "256")]
            Blake2b256,
            #[serde(rename = "384")]
            Blake2b384,
            #[serde(rename = "512")]
            Blake2b512,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SupportedBlake2bSize {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 5",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "128" => _serde::__private::Ok(__Field::__field0),
                                "160" => _serde::__private::Ok(__Field::__field1),
                                "256" => _serde::__private::Ok(__Field::__field2),
                                "384" => _serde::__private::Ok(__Field::__field3),
                                "512" => _serde::__private::Ok(__Field::__field4),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"128" => _serde::__private::Ok(__Field::__field0),
                                b"160" => _serde::__private::Ok(__Field::__field1),
                                b"256" => _serde::__private::Ok(__Field::__field2),
                                b"384" => _serde::__private::Ok(__Field::__field3),
                                b"512" => _serde::__private::Ok(__Field::__field4),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SupportedBlake2bSize>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SupportedBlake2bSize;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum SupportedBlake2bSize",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedBlake2bSize::Blake2b128)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedBlake2bSize::Blake2b160)
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedBlake2bSize::Blake2b256)
                                }
                                (__Field::__field3, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedBlake2bSize::Blake2b384)
                                }
                                (__Field::__field4, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedBlake2bSize::Blake2b512)
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "128",
                        "160",
                        "256",
                        "384",
                        "512",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "SupportedBlake2bSize",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                SupportedBlake2bSize,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[serde(rename_all = "lowercase")]
        enum SupportedOutputFormat {
            Hex,
            Base64,
            Uint8Array,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SupportedOutputFormat {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 3",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "hex" => _serde::__private::Ok(__Field::__field0),
                                "base64" => _serde::__private::Ok(__Field::__field1),
                                "uint8array" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"hex" => _serde::__private::Ok(__Field::__field0),
                                b"base64" => _serde::__private::Ok(__Field::__field1),
                                b"uint8array" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SupportedOutputFormat>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SupportedOutputFormat;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum SupportedOutputFormat",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedOutputFormat::Hex)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedOutputFormat::Base64)
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedOutputFormat::Uint8Array)
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "hex",
                        "base64",
                        "uint8array",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "SupportedOutputFormat",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                SupportedOutputFormat,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct Params {
            key: Option<String>,
            key_format: Option<SupportedFormats>,
            size: SupportedBlake2bSize,
            output_format: SupportedOutputFormat,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Params {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "key" => _serde::__private::Ok(__Field::__field0),
                                "key_format" => _serde::__private::Ok(__Field::__field1),
                                "size" => _serde::__private::Ok(__Field::__field2),
                                "output_format" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"key" => _serde::__private::Ok(__Field::__field0),
                                b"key_format" => _serde::__private::Ok(__Field::__field1),
                                b"size" => _serde::__private::Ok(__Field::__field2),
                                b"output_format" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Params>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Params;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Params",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Params with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Option<SupportedFormats>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Params with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                SupportedBlake2bSize,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct Params with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                SupportedOutputFormat,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct Params with 4 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Params {
                                key: __field0,
                                key_format: __field1,
                                size: __field2,
                                output_format: __field3,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                Option<SupportedFormats>,
                            > = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                SupportedBlake2bSize,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<
                                SupportedOutputFormat,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("key"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "key_format",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<SupportedFormats>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("size"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SupportedBlake2bSize,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "output_format",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SupportedOutputFormat,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("key")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("key_format")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("size")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("output_format")?
                                }
                            };
                            _serde::__private::Ok(Params {
                                key: __field0,
                                key_format: __field1,
                                size: __field2,
                                output_format: __field3,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "key",
                        "key_format",
                        "size",
                        "output_format",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Params",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Params>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct DeserializeMeDaddy {
            input: String,
            params: Params,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                "params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                b"params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Params,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Params> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("params"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Params>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("params")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input", "params"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// BLAKE2b is a flavour of the BLAKE cryptographic hash function that is optimized for 64-bit platforms and produces digests of any size between 1 and 64 bytes.
        /// <br><br/>
        /// For more information go [here](https://wikipedia.org/wiki/BLAKE_(hash_function)#BLAKE2b_algorithm).
        /// <br><br/>
        ///
        /// # How to use
        /// \
        /// Send POST requests to /api/Blake2b with your data using json payload with this structure.
        /// ``` json
        /// {
        ///     "input": string,
        ///     "params": {
        ///         "key": Option<String>,
        ///         "key_format": Option<SupportedFormats>,
        ///         "size": SupportedBlake2bSize,
        ///         "output_format": SupportedOutputFormat
        ///     }
        /// }
        /// ```
        /// #### where
        ///     - Option<String> is optional argument with type of string
        ///     - Option<SupportedFormats> is optional enum of "binary", "utf8", "hex", "base64", "latin1"
        ///     - SupportedBlake2bSize is enum of "128", "160", "256", "384", "512"
        ///     - SupportedOutputFormat is enum of "hex", "base64", "uint8array"
        /// <br/><br/>
        ///
        /// ### Server response have two possible formats
        ///
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
        /// ``` json
        /// {
        ///   "Ok": {
        ///     "hex|base64|uint8array": "string|uint8array"
        ///   }
        /// }
        /// ```
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
        /// ``` json
        /// { "Err": `error message` }
        /// ```
        /// # Examples
        /// ## №1
        /// ``` http
        /// POST /api/Blake2b
        ///
        /// {
        ///     "input": "hello world",
        ///     "params": {
        ///         "size": "160",
        ///         "key": "super secret key",
        ///         "output_format": "base64"
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {
        ///     "Ok": {
        ///         "base64": "ktyh3oJo3OG/51S6SrnE6lzvSuk="
        ///     }
        /// }
        /// ```
        /// ## №2
        /// ``` http
        /// POST /api/Blake2b
        ///
        /// {
        ///     "input": "hello",
        ///     "params": {
        ///         "size": "128",
        ///         "output_format": "hex"
        ///     }
        /// }
        /// ```
        /// ```http
        /// {
        ///     "Ok": {
        ///         "hex": "46fb7408d4f285228f4af516ea25851b"
        ///     }
        /// }
        /// ```
        /// ## №3
        /// ``` http
        /// POST /api/Blake2b
        ///
        /// {
        ///     "input": "hello",
        ///     "params": {
        ///         "size": "128",
        ///         "key": "key format not set"
        ///         "output_format": "hex"
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 400 Bad Request
        /// {
        ///   "Err": "Key format argument must be set."
        /// }
        /// ```
        pub struct Blake2b;
        const NAME: &str = "Blake2b";
        const DESCRIPTION_EN: &str = "Performs BLAKE2b hashing on the input.";
        const DESCRIPTION_RU: &str = "Выполняет хеширование BLAKE2b на входных данных.";
        const INFO_URL: Option<&str> = Some(
            "https://wikipedia.org/wiki/BLAKE_(hash_function)#BLAKE2b_algorithm",
        );
        pub struct Blake2bInfo {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Blake2bInfo {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "Blake2bInfo",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl Blake2bInfo {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub mod blake2s_mod {
        use crate::{
            create_info_struct, create_me_daddy, create_tauri_wrapper,
            libs::base64::to_base64, run_operations,
            utils::{convert_to_byte_array, to_hex, SupportedFormats},
            Operation, DOCS_URL,
        };
        use anyhow::{bail, Result};
        use blake2::{
            digest::{Update, VariableOutput},
            VarBlake2s,
        };
        use serde::{Deserialize, Serialize};
        pub fn blake2s(request: &str) -> Result<String, String> {
            run_operations(Blake2s, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__blake2s;
        impl Operation<'_, DeserializeMeDaddy> for Blake2s {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let (input, size, key, key_format, output_format) = (
                    request.input,
                    request.params.size,
                    request.params.key,
                    request.params.key_format,
                    request.params.output_format,
                );
                let key = match key {
                    None => Vec::new(),
                    Some(key) => {
                        match key_format {
                            None => {
                                return ::anyhow::__private::Err({
                                    let error = ::anyhow::__private::format_err(
                                        format_args!("Key format argument must be set."),
                                    );
                                    error
                                });
                            }
                            Some(key_format) => convert_to_byte_array(&key, &key_format)?,
                        }
                    }
                };
                let mut hasher = VarBlake2s::new_keyed(
                    &key,
                    match size {
                        SupportedBlake2sSize::Blake2s128 => 16,
                        SupportedBlake2sSize::Blake2s160 => 20,
                        SupportedBlake2sSize::Blake2s256 => 32,
                        SupportedBlake2sSize::Blake2s384 => 48,
                        SupportedBlake2sSize::Blake2s512 => 64,
                    },
                );
                hasher.update(input.as_bytes());
                let res = hasher.finalize_boxed();
                Ok(
                    match output_format {
                        SupportedOutputFormat::Hex => to_hex(&res),
                        SupportedOutputFormat::Base64 => to_base64(&res, None)?,
                        SupportedOutputFormat::Uint8Array => {
                            String::from_utf8_lossy(&res).to_string()
                        }
                    },
                )
            }
        }
        enum SupportedBlake2sSize {
            #[serde(rename = "128")]
            Blake2s128,
            #[serde(rename = "160")]
            Blake2s160,
            #[serde(rename = "256")]
            Blake2s256,
            #[serde(rename = "384")]
            Blake2s384,
            #[serde(rename = "512")]
            Blake2s512,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SupportedBlake2sSize {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 5",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "128" => _serde::__private::Ok(__Field::__field0),
                                "160" => _serde::__private::Ok(__Field::__field1),
                                "256" => _serde::__private::Ok(__Field::__field2),
                                "384" => _serde::__private::Ok(__Field::__field3),
                                "512" => _serde::__private::Ok(__Field::__field4),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"128" => _serde::__private::Ok(__Field::__field0),
                                b"160" => _serde::__private::Ok(__Field::__field1),
                                b"256" => _serde::__private::Ok(__Field::__field2),
                                b"384" => _serde::__private::Ok(__Field::__field3),
                                b"512" => _serde::__private::Ok(__Field::__field4),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SupportedBlake2sSize>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SupportedBlake2sSize;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum SupportedBlake2sSize",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedBlake2sSize::Blake2s128)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedBlake2sSize::Blake2s160)
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedBlake2sSize::Blake2s256)
                                }
                                (__Field::__field3, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedBlake2sSize::Blake2s384)
                                }
                                (__Field::__field4, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedBlake2sSize::Blake2s512)
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "128",
                        "160",
                        "256",
                        "384",
                        "512",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "SupportedBlake2sSize",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                SupportedBlake2sSize,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[serde(rename_all = "lowercase")]
        enum SupportedOutputFormat {
            Hex,
            Base64,
            Uint8Array,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SupportedOutputFormat {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 3",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "hex" => _serde::__private::Ok(__Field::__field0),
                                "base64" => _serde::__private::Ok(__Field::__field1),
                                "uint8array" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"hex" => _serde::__private::Ok(__Field::__field0),
                                b"base64" => _serde::__private::Ok(__Field::__field1),
                                b"uint8array" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SupportedOutputFormat>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SupportedOutputFormat;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum SupportedOutputFormat",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedOutputFormat::Hex)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedOutputFormat::Base64)
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedOutputFormat::Uint8Array)
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "hex",
                        "base64",
                        "uint8array",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "SupportedOutputFormat",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                SupportedOutputFormat,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct Params {
            key: Option<String>,
            key_format: Option<SupportedFormats>,
            size: SupportedBlake2sSize,
            output_format: SupportedOutputFormat,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Params {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "key" => _serde::__private::Ok(__Field::__field0),
                                "key_format" => _serde::__private::Ok(__Field::__field1),
                                "size" => _serde::__private::Ok(__Field::__field2),
                                "output_format" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"key" => _serde::__private::Ok(__Field::__field0),
                                b"key_format" => _serde::__private::Ok(__Field::__field1),
                                b"size" => _serde::__private::Ok(__Field::__field2),
                                b"output_format" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Params>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Params;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Params",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Params with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Option<SupportedFormats>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Params with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                SupportedBlake2sSize,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct Params with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                SupportedOutputFormat,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct Params with 4 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Params {
                                key: __field0,
                                key_format: __field1,
                                size: __field2,
                                output_format: __field3,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                Option<SupportedFormats>,
                            > = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                SupportedBlake2sSize,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<
                                SupportedOutputFormat,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("key"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "key_format",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<SupportedFormats>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("size"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SupportedBlake2sSize,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "output_format",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SupportedOutputFormat,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("key")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("key_format")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("size")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("output_format")?
                                }
                            };
                            _serde::__private::Ok(Params {
                                key: __field0,
                                key_format: __field1,
                                size: __field2,
                                output_format: __field3,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "key",
                        "key_format",
                        "size",
                        "output_format",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Params",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Params>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct DeserializeMeDaddy {
            input: String,
            params: Params,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                "params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                b"params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Params,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Params> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("params"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Params>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("params")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input", "params"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// BLAKE2s is a flavour of the BLAKE cryptographic hash function that is optimized for 8- to 32-bit platforms and produces digests of any size between 1 and 32 bytes.
        /// <br><br/>
        /// For more information go [here](https://wikipedia.org/wiki/BLAKE_(hash_function)#BLAKE2).
        /// <br><br/>
        ///
        /// # How to use
        /// \
        /// Send POST requests to /api/Blake2s with your data using json payload with this structure.
        /// ``` json
        /// {
        ///     "input": string,
        ///     "params": {
        ///         "key": Option<String>,
        ///         "key_format": Option<SupportedFormats>,
        ///         "size": SupportedBlake2sSize,
        ///         "output_format": SupportedOutputFormat
        ///     }
        /// }
        /// ```
        /// #### where
        ///     - Option<String> is optional argument with type of string
        ///     - Option<SupportedFormats> is optional enum of "binary", "utf8", "hex", "base64", "latin1"
        ///     - SupportedBlake2sSize is enum of "128", "160", "256", "384", "512"
        ///     - SupportedOutputFormat is enum of "hex", "base64", "uint8array"
        /// <br/><br/>
        ///
        /// ### Server response have two possible formats
        ///
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
        /// ``` json
        /// {
        ///   "Ok": {
        ///     "hex|base64|uint8array": "string|uint8array"
        ///   }
        /// }
        /// ```
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
        /// ``` json
        /// { "Err": `error message` }
        /// ```
        /// # Examples
        /// ## №1
        /// ``` http
        /// POST /api/Blake2s
        ///
        /// {
        ///     "input": "hello world",
        ///     "params": {
        ///         "size": "160",
        ///         "key": "c3VwZXIgc2VjcmV0IGtleQ=",
        ///         "key_format": "base64",
        ///         "output_format": "base64"
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {
        ///     "Ok": {
        ///         "base64": "7Y12BJIsWVVt5Oj36MRs0OPzN4o="
        ///     }
        /// }
        /// ```
        /// ## №2
        /// ``` http
        /// POST /api/Blake2s
        ///
        /// {
        ///     "input": "hello",
        ///     "params": {
        ///         "size": "128",
        ///         "output_format": "hex"
        ///     }
        /// }
        /// ```
        /// ```http
        /// {
        ///     "Ok": {
        ///         "hex": "96d539653dbf841c384b53d5f04658e5"
        ///     }
        /// }
        /// ```
        /// ## №3
        /// ``` http
        /// POST /api/Blake2s
        ///
        /// {
        ///     "input": "hello",
        ///     "params": {
        ///         "size": "128",
        ///         "key": "key format not set"
        ///         "output_format": "hex"
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 400 Bad Request
        /// {
        ///   "Err": "Key format argument must be set."
        /// }
        /// ```
        pub struct Blake2s;
        const NAME: &str = "Blake2s";
        const DESCRIPTION_EN: &str = "Performs BLAKE2s hashing on the input.";
        const DESCRIPTION_RU: &str = "Выполняет хеширование BLAKE2s на входных данных.";
        const INFO_URL: Option<&str> = Some(
            "https://wikipedia.org/wiki/BLAKE_(hash_function)#BLAKE2",
        );
        pub struct Blake2sInfo {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Blake2sInfo {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "Blake2sInfo",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl Blake2sInfo {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub mod filter_mod {
        use crate::{
            create_me_daddy, create_tauri_wrapper, run_operations,
            utils::SupportedDelimiter, Operation,
        };
        use anyhow::Result;
        use serde::Deserialize;
        pub fn filter(request: &str) -> Result<String, String> {
            run_operations(Filter, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__filter;
        impl Operation<'_, DeserializeMeDaddy> for Filter {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let (input, Params { delimiter, regex, invert_condition }) = (
                    request.input,
                    request.params,
                );
                let regex = regex::Regex::new(&regex)?;
                let output: String = input
                    .split(&delimiter.to_string())
                    .filter(|x| regex.is_match(x) != invert_condition)
                    .collect();
                Ok(output)
            }
        }
        struct Params {
            delimiter: SupportedDelimiter,
            regex: String,
            invert_condition: bool,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Params {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "delimiter" => _serde::__private::Ok(__Field::__field0),
                                "regex" => _serde::__private::Ok(__Field::__field1),
                                "invert_condition" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"delimiter" => _serde::__private::Ok(__Field::__field0),
                                b"regex" => _serde::__private::Ok(__Field::__field1),
                                b"invert_condition" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Params>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Params;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Params",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                SupportedDelimiter,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Params with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Params with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                bool,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct Params with 3 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Params {
                                delimiter: __field0,
                                regex: __field1,
                                invert_condition: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                SupportedDelimiter,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<bool> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "delimiter",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SupportedDelimiter,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("regex"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "invert_condition",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("delimiter")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("regex")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("invert_condition")?
                                }
                            };
                            _serde::__private::Ok(Params {
                                delimiter: __field0,
                                regex: __field1,
                                invert_condition: __field2,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "delimiter",
                        "regex",
                        "invert_condition",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Params",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Params>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct DeserializeMeDaddy {
            input: String,
            params: Params,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                "params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                b"params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Params,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Params> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("params"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Params>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("params")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input", "params"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub struct Filter;
    }
    pub mod from_base64_mod {
        use serde::{Deserialize, Serialize};
        use crate::{
            create_info_struct, create_me_daddy, create_tauri_wrapper,
            libs::base64::from_base64 as from_base64_lib, run_operations,
            utils::{DataRepresentation, DataRepresentationInput},
            Operation, DOCS_URL,
        };
        use anyhow::{bail, Result};
        pub fn from_base64(request: &str) -> Result<String, String> {
            run_operations(FromBase64, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__from_base64;
        impl Operation<'_, DeserializeMeDaddy> for FromBase64 {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let (input, alphabet, remove_non_alphabetic_chars, strict_mode) = (
                    request.input,
                    request.params.alphabet,
                    request.params.remove_non_alphabetic_chars.unwrap_or_default(),
                    request.params.strict_mode.unwrap_or_default(),
                );
                let alphabet = alphabet.unwrap_or_default();
                match from_base64_lib(
                    input,
                    &alphabet,
                    DataRepresentationInput::String,
                    remove_non_alphabetic_chars,
                    strict_mode,
                ) {
                    Ok(output) => {
                        let DataRepresentation::String(output) = output else {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        ) };
                        Ok(output.trim_end_matches('\0').to_string())
                    }
                    Err(e) => {
                        return ::anyhow::__private::Err({
                            use ::anyhow::__private::kind::*;
                            let error = match e {
                                error => (&error).anyhow_kind().new(error),
                            };
                            error
                        });
                    }
                }
            }
        }
        struct Params {
            alphabet: Option<String>,
            remove_non_alphabetic_chars: Option<bool>,
            strict_mode: Option<bool>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Params {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "alphabet" => _serde::__private::Ok(__Field::__field0),
                                "remove_non_alphabetic_chars" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                "strict_mode" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"alphabet" => _serde::__private::Ok(__Field::__field0),
                                b"remove_non_alphabetic_chars" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                b"strict_mode" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Params>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Params;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Params",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Params with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Option<bool>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Params with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                Option<bool>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct Params with 3 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Params {
                                alphabet: __field0,
                                remove_non_alphabetic_chars: __field1,
                                strict_mode: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Option<bool>> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<Option<bool>> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "alphabet",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "remove_non_alphabetic_chars",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<bool>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "strict_mode",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<bool>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("alphabet")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field(
                                        "remove_non_alphabetic_chars",
                                    )?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("strict_mode")?
                                }
                            };
                            _serde::__private::Ok(Params {
                                alphabet: __field0,
                                remove_non_alphabetic_chars: __field1,
                                strict_mode: __field2,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "alphabet",
                        "remove_non_alphabetic_chars",
                        "strict_mode",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Params",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Params>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct DeserializeMeDaddy {
            input: String,
            params: Params,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                "params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                b"params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Params,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Params> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("params"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Params>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("params")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input", "params"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// Base64 is a notation for encoding arbitrary byte data using a restricted set of symbols that can be conveniently used by humans and processed by computers.<br><br>This operation decodes raw data into an ASCII Base64 string.
        /// <br><br/>
        /// For more information go [here](https://wikipedia.org/wiki/Base64).
        /// <br><br/>
        ///
        /// # How to use
        /// \
        /// Send POST requests to /api/FromBase64 with your data using json payload with this structure.
        /// ``` json
        /// {
        ///     "input": string,
        ///     "params": {
        ///         "alphabet": Option<string>,
        ///         "remove_non_alphabetic_chars": Option<bool>,
        ///         "strict_mode": Option<bool>
        ///     }
        /// }
        /// ```
        /// #### where
        ///     - Option<string> is type that can be string or null.
        ///     - Option<bool> is type that can be bool or null.
        /// <br/><br/>
        ///
        /// ### Server response have two possible formats
        ///
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
        /// ``` json
        /// { "Ok": `some answer` }
        /// ```
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
        /// ``` json
        /// { "Err": `error message` }
        /// ```
        /// # Examples
        /// ## №1
        /// ``` http
        /// POST /api/FromBase64
        ///
        /// {
        ///     "input": "aGVsbG8=",
        ///     "params": {
        ///         "alphabet": "A-Za-z0-9+/=",
        ///         "remove_non_alphabetic_chars": false,
        ///         "strict_mode": false
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {
        ///   "Ok": "hello"
        /// }
        /// ```
        /// ## №2
        /// ``` http
        /// POST /api/FromBase64
        ///
        /// {
        ///     "input": ":&5L;&\",
        ///     "params": {
        ///         "alphabet": " -_",
        ///         "remove_non_alphabetic_chars": false,
        ///         "strict_mode": false
        ///     }
        /// }
        /// ``
        /// ```
        /// ```http
        /// {
        ///   "Ok": "hello"
        /// }
        /// ```
        /// ## №3
        /// ``` http
        /// POST /api/FromBase64
        /// content_type: application/json; charset=utf-8
        ///
        /// {
        ///     "input": ":&5L;&\",
        ///     "params": {
        ///         "alphabet": " -_",
        ///         "remove_non_alphabetic_chars": false
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 400 Bad Request
        /// {
        ///   "Err": "Missing field `strict_mode`."
        /// }
        /// ```
        pub struct FromBase64;
        const NAME: &str = "FromBase64";
        const DESCRIPTION_EN: &str = "Base64 is a notation for encoding arbitrary byte data using a restricted set of symbols that can be conveniently used by humans and processed by computers.<br><br>This operation decodes raw data into an ASCII Base64 string.";
        const DESCRIPTION_RU: &str = "Base64 — это нотация для кодирования произвольных байтовых данных с использованием ограниченного набора символов, которые могут удобно использоваться людьми и обрабатываться компьютерами.<br><br>Эта операция декодирует необработанные данные в строку ASCII Base64.";
        const INFO_URL: Option<&str> = Some("https://wikipedia.org/wiki/Base64");
        pub struct FromBase64Info {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for FromBase64Info {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "FromBase64Info",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl FromBase64Info {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub mod from_base_mod {
        use num::{BigInt, Num};
        use serde::{Deserialize, Serialize};
        use serde_valid::Validate;
        use crate::{
            create_info_struct, create_me_daddy, create_tauri_wrapper, run_operations,
            Operation, DOCS_URL,
        };
        use anyhow::Result;
        pub fn from_base(request: &str) -> Result<String, String> {
            run_operations(FromBase, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__from_base;
        impl Operation<'_, DeserializeMeDaddy> for FromBase {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let (input, radix) = (request.input, request.params.radix);
                #[allow(non_snake_case)]
                let big_D_number = BigInt::from_str_radix(&input, radix)?;
                Ok(big_D_number.to_string())
            }
        }
        struct Params {
            #[validate(maximum = 36)]
            #[validate(minimum = 2)]
            radix: u32,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Params {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "radix" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"radix" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Params>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Params;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Params",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                u32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Params with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Params { radix: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<u32> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("radix"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("radix")?
                                }
                            };
                            _serde::__private::Ok(Params { radix: __field0 })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["radix"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Params",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Params>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl ::serde_valid::Validate for Params {
            fn validate(
                &self,
            ) -> std::result::Result<(), ::serde_valid::validation::Errors> {
                let mut __rule_vec_errors = ::serde_valid::validation::VecErrors::new();
                let mut __property_vec_errors_map = ::serde_valid::validation::PropertyVecErrorsMap::new();
                let radix = &self.radix;
                if let Err(__composited_error_params)
                    = ::serde_valid::validation::ValidateCompositedMaximum::validate_composited_maximum(
                        radix,
                        36,
                    ) {
                    use ::serde_valid::validation::{IntoError, ToDefaultMessage};
                    __property_vec_errors_map
                        .entry("radix".to_string())
                        .or_default()
                        .push(
                            __composited_error_params
                                .into_error_by(::serde_valid::validation::CustomMessage {
                                    message_fn: ::serde_valid::validation::ToDefaultMessage::to_default_message,
                                }),
                        );
                }
                if let Err(__composited_error_params)
                    = ::serde_valid::validation::ValidateCompositedMinimum::validate_composited_minimum(
                        radix,
                        2,
                    ) {
                    use ::serde_valid::validation::{IntoError, ToDefaultMessage};
                    __property_vec_errors_map
                        .entry("radix".to_string())
                        .or_default()
                        .push(
                            __composited_error_params
                                .into_error_by(::serde_valid::validation::CustomMessage {
                                    message_fn: ::serde_valid::validation::ToDefaultMessage::to_default_message,
                                }),
                        );
                }
                if __rule_vec_errors.is_empty() && __property_vec_errors_map.is_empty() {
                    Ok(())
                } else {
                    Err(
                        ::serde_valid::validation::Errors::Object(
                            ::serde_valid::validation::ObjectErrors::new(
                                __rule_vec_errors,
                                __property_vec_errors_map
                                    .into_iter()
                                    .map(|(field, errors)| {
                                        let mut __field_items_errors = ::alloc::vec::Vec::new();
                                        let mut __field_properties_errors = None;
                                        let mut __field_errors: ::serde_valid::validation::VecErrors = errors
                                            .into_iter()
                                            .filter_map(|error| match error {
                                                ::serde_valid::validation::Error::Items(__array_errors) => {
                                                    __field_items_errors.push(__array_errors);
                                                    None
                                                }
                                                ::serde_valid::validation::Error::Properties(
                                                    __object_errors,
                                                ) => {
                                                    __field_properties_errors = Some(__object_errors);
                                                    None
                                                }
                                                _ => Some(error),
                                            })
                                            .collect();
                                        if let Some(__object_errors) = __field_properties_errors {
                                            __field_errors.extend(__object_errors.errors);
                                            (
                                                field,
                                                ::serde_valid::validation::Errors::Object(
                                                    ::serde_valid::validation::ObjectErrors::new(
                                                        __field_errors,
                                                        __object_errors.properties,
                                                    ),
                                                ),
                                            )
                                        } else if !__field_items_errors.is_empty() {
                                            let __array_errors = __field_items_errors
                                                .into_iter()
                                                .reduce(|a, b| a.merge(b))
                                                .unwrap();
                                            __field_errors.extend(__array_errors.errors);
                                            (
                                                field,
                                                ::serde_valid::validation::Errors::Array(
                                                    ::serde_valid::validation::ArrayErrors::new(
                                                        __field_errors,
                                                        __array_errors.items,
                                                    ),
                                                ),
                                            )
                                        } else {
                                            (
                                                field,
                                                ::serde_valid::validation::Errors::NewType(__field_errors),
                                            )
                                        }
                                    })
                                    .collect(),
                            ),
                        ),
                    )
                }
            }
        }
        struct DeserializeMeDaddy {
            input: String,
            params: Params,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                "params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                b"params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Params,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Params> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("params"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Params>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("params")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input", "params"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// Converts a number to decimal from a given numerical base.
        /// <br><br/>
        /// For more information go [here](https://wikipedia.org/wiki/Radix).
        /// <br><br/>
        ///
        /// # How to use
        /// \
        /// Send POST requests to /api/FromBase with your data using json payload with this structure.
        /// ``` json
        /// {
        ///     "input": string,
        ///     "params": {
        ///         "radix": u36,
        ///     }
        /// }
        /// ```
        /// #### where
        ///     - u36 is digit between 2 and 36 inclusive
        /// <br/><br/>
        ///
        /// ### Server response have two possible formats
        ///
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
        /// ``` json
        /// { "Ok": `some answer` }
        /// ```
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
        /// ``` json
        /// { "Err": `error message` }
        /// ```
        /// # Examples
        /// ## №1
        /// ``` http
        /// POST /api/FromBase
        ///
        /// {
        ///     "input": "123",
        ///     "params": {
        ///         "radix": 15
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {
        ///   "Ok": "258"
        /// }
        /// ```
        /// ## №2
        /// ``` http
        /// POST /api/FromBase
        ///
        /// {
        ///     "input": "6ba754a0cd1c90784e4c0ade35dbe8dfcceaf520e77c51a5b21ce5c2",
        ///     "params": {
        ///         "radix": 33
        ///     }
        /// }
        /// ``
        /// ```
        /// ```http
        /// {
        ///   "Ok": "2091904736137844619429815059353840143519387965190608554254592830964315299383632619562"
        /// }
        /// ```
        /// ## №3
        /// ``` http
        /// POST /api/FromBase
        /// content_type: application/json; charset=utf-8
        ///
        /// {
        ///     "input": "deadbeef",
        ///     "params": {
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 400 Bad Request
        /// {
        ///   "Err": "Missing field `radix`."
        /// }
        /// ```
        pub struct FromBase;
        const NAME: &str = "FromBase";
        const DESCRIPTION_EN: &str = "Converts a number to decimal from a given numerical base.";
        const DESCRIPTION_RU: &str = "Преобразует число в десятичное по заданной системе счисления.";
        const INFO_URL: Option<&str> = Some("https://wikipedia.org/wiki/Radix");
        pub struct FromBaseInfo {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for FromBaseInfo {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "FromBaseInfo",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl FromBaseInfo {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub mod hmac_mod {
        use anyhow::Result;
        use hmac::{Hmac as m_hmac, Mac};
        use md2::*;
        use md4::*;
        use md5::*;
        use ripemd::*;
        use serde::{Deserialize, Serialize};
        use sha1::Sha1;
        use sha2::*;
        use whirlpool::*;
        use crate::{
            create_info_struct, create_me_daddy, create_tauri_wrapper,
            libs::base64::to_base64, run_operations,
            utils::{convert_to_byte_array, to_hex, SupportedFormats},
            Operation, DOCS_URL,
        };
        pub fn hmac(request: &str) -> Result<String, String> {
            run_operations(Hmac, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__hmac;
        impl Operation<'_, DeserializeMeDaddy> for Hmac {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let (input, key, key_format, hash_function, output_format) = (
                    request.input,
                    request.params.key,
                    request.params.key_format,
                    request.params.hash_function,
                    request.params.output_format,
                );
                let key = convert_to_byte_array(&key, &key_format)?;
                let res = match hash_function {
                    SupportedHashFunctions::MD2 => {
                        let mut hasher = HmacMD2::new_from_slice(&key)?;
                        hasher.update(input.as_bytes());
                        hasher.finalize().into_bytes().to_vec()
                    }
                    SupportedHashFunctions::MD4 => {
                        let mut hasher = HmacMD4::new_from_slice(&key)?;
                        hasher.update(input.as_bytes());
                        hasher.finalize().into_bytes().to_vec()
                    }
                    SupportedHashFunctions::MD5 => {
                        let mut hasher = HmacMD5::new_from_slice(&key)?;
                        hasher.update(input.as_bytes());
                        hasher.finalize().into_bytes().to_vec()
                    }
                    SupportedHashFunctions::SHA1 => {
                        let mut hasher = HmacSha1::new_from_slice(&key)?;
                        hasher.update(input.as_bytes());
                        hasher.finalize().into_bytes().to_vec()
                    }
                    SupportedHashFunctions::SHA224 => {
                        let mut hasher = HmacSha224::new_from_slice(&key)?;
                        hasher.update(input.as_bytes());
                        hasher.finalize().into_bytes().to_vec()
                    }
                    SupportedHashFunctions::SHA256 => {
                        let mut hasher = HmacSha256::new_from_slice(&key)?;
                        hasher.update(input.as_bytes());
                        hasher.finalize().into_bytes().to_vec()
                    }
                    SupportedHashFunctions::SHA384 => {
                        let mut hasher = HmacSha384::new_from_slice(&key)?;
                        hasher.update(input.as_bytes());
                        hasher.finalize().into_bytes().to_vec()
                    }
                    SupportedHashFunctions::SHA512 => {
                        let mut hasher = HmacSha512::new_from_slice(&key)?;
                        hasher.update(input.as_bytes());
                        hasher.finalize().into_bytes().to_vec()
                    }
                    SupportedHashFunctions::SHA512_224 => {
                        let mut hasher = HmacSha512_224::new_from_slice(&key)?;
                        hasher.update(input.as_bytes());
                        hasher.finalize().into_bytes().to_vec()
                    }
                    SupportedHashFunctions::SHA512_256 => {
                        let mut hasher = HmacSha512_256::new_from_slice(&key)?;
                        hasher.update(input.as_bytes());
                        hasher.finalize().into_bytes().to_vec()
                    }
                    SupportedHashFunctions::Ripemd128 => {
                        let mut hasher = HmacRipemd128::new_from_slice(&key)?;
                        hasher.update(input.as_bytes());
                        hasher.finalize().into_bytes().to_vec()
                    }
                    SupportedHashFunctions::Ripemd160 => {
                        let mut hasher = HmacRipemd160::new_from_slice(&key)?;
                        hasher.update(input.as_bytes());
                        hasher.finalize().into_bytes().to_vec()
                    }
                    SupportedHashFunctions::Ripemd256 => {
                        let mut hasher = HmacRipemd256::new_from_slice(&key)?;
                        hasher.update(input.as_bytes());
                        hasher.finalize().into_bytes().to_vec()
                    }
                    SupportedHashFunctions::Ripemd320 => {
                        let mut hasher = HmacRipemd320::new_from_slice(&key)?;
                        hasher.update(input.as_bytes());
                        hasher.finalize().into_bytes().to_vec()
                    }
                    SupportedHashFunctions::WhirlPool => {
                        let mut hasher = HmacWhirlPool::new_from_slice(&key)?;
                        hasher.update(input.as_bytes());
                        hasher.finalize().into_bytes().to_vec()
                    }
                };
                Ok(
                    match output_format {
                        SupportedOutputFormat::Hex => to_hex(&res),
                        SupportedOutputFormat::Base64 => to_base64(&res, None)?,
                        SupportedOutputFormat::Raw => {
                            String::from_utf8_lossy(&res).to_string()
                        }
                    },
                )
            }
        }
        type HmacMD2 = m_hmac<Md2>;
        type HmacMD4 = m_hmac<Md4>;
        type HmacMD5 = m_hmac<Md5>;
        type HmacSha1 = m_hmac<Sha1>;
        type HmacSha224 = m_hmac<Sha224>;
        type HmacSha256 = m_hmac<Sha256>;
        type HmacSha384 = m_hmac<Sha384>;
        type HmacSha512 = m_hmac<Sha512>;
        type HmacSha512_224 = m_hmac<Sha512_224>;
        type HmacSha512_256 = m_hmac<Sha512_256>;
        type HmacRipemd128 = m_hmac<Ripemd128>;
        type HmacRipemd160 = m_hmac<Ripemd160>;
        type HmacRipemd256 = m_hmac<Ripemd256>;
        type HmacRipemd320 = m_hmac<Ripemd320>;
        type HmacWhirlPool = m_hmac<Whirlpool>;
        #[serde(rename_all = "lowercase")]
        enum SupportedHashFunctions {
            MD2,
            MD4,
            MD5,
            SHA1,
            SHA224,
            SHA256,
            SHA384,
            SHA512,
            SHA512_224,
            SHA512_256,
            Ripemd128,
            Ripemd160,
            Ripemd256,
            Ripemd320,
            WhirlPool,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SupportedHashFunctions {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __field8,
                        __field9,
                        __field10,
                        __field11,
                        __field12,
                        __field13,
                        __field14,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                8u64 => _serde::__private::Ok(__Field::__field8),
                                9u64 => _serde::__private::Ok(__Field::__field9),
                                10u64 => _serde::__private::Ok(__Field::__field10),
                                11u64 => _serde::__private::Ok(__Field::__field11),
                                12u64 => _serde::__private::Ok(__Field::__field12),
                                13u64 => _serde::__private::Ok(__Field::__field13),
                                14u64 => _serde::__private::Ok(__Field::__field14),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 15",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "md2" => _serde::__private::Ok(__Field::__field0),
                                "md4" => _serde::__private::Ok(__Field::__field1),
                                "md5" => _serde::__private::Ok(__Field::__field2),
                                "sha1" => _serde::__private::Ok(__Field::__field3),
                                "sha224" => _serde::__private::Ok(__Field::__field4),
                                "sha256" => _serde::__private::Ok(__Field::__field5),
                                "sha384" => _serde::__private::Ok(__Field::__field6),
                                "sha512" => _serde::__private::Ok(__Field::__field7),
                                "sha512_224" => _serde::__private::Ok(__Field::__field8),
                                "sha512_256" => _serde::__private::Ok(__Field::__field9),
                                "ripemd128" => _serde::__private::Ok(__Field::__field10),
                                "ripemd160" => _serde::__private::Ok(__Field::__field11),
                                "ripemd256" => _serde::__private::Ok(__Field::__field12),
                                "ripemd320" => _serde::__private::Ok(__Field::__field13),
                                "whirlpool" => _serde::__private::Ok(__Field::__field14),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"md2" => _serde::__private::Ok(__Field::__field0),
                                b"md4" => _serde::__private::Ok(__Field::__field1),
                                b"md5" => _serde::__private::Ok(__Field::__field2),
                                b"sha1" => _serde::__private::Ok(__Field::__field3),
                                b"sha224" => _serde::__private::Ok(__Field::__field4),
                                b"sha256" => _serde::__private::Ok(__Field::__field5),
                                b"sha384" => _serde::__private::Ok(__Field::__field6),
                                b"sha512" => _serde::__private::Ok(__Field::__field7),
                                b"sha512_224" => _serde::__private::Ok(__Field::__field8),
                                b"sha512_256" => _serde::__private::Ok(__Field::__field9),
                                b"ripemd128" => _serde::__private::Ok(__Field::__field10),
                                b"ripemd160" => _serde::__private::Ok(__Field::__field11),
                                b"ripemd256" => _serde::__private::Ok(__Field::__field12),
                                b"ripemd320" => _serde::__private::Ok(__Field::__field13),
                                b"whirlpool" => _serde::__private::Ok(__Field::__field14),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SupportedHashFunctions>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SupportedHashFunctions;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum SupportedHashFunctions",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedHashFunctions::MD2)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedHashFunctions::MD4)
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedHashFunctions::MD5)
                                }
                                (__Field::__field3, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedHashFunctions::SHA1)
                                }
                                (__Field::__field4, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedHashFunctions::SHA224)
                                }
                                (__Field::__field5, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedHashFunctions::SHA256)
                                }
                                (__Field::__field6, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedHashFunctions::SHA384)
                                }
                                (__Field::__field7, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedHashFunctions::SHA512)
                                }
                                (__Field::__field8, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedHashFunctions::SHA512_224)
                                }
                                (__Field::__field9, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedHashFunctions::SHA512_256)
                                }
                                (__Field::__field10, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedHashFunctions::Ripemd128)
                                }
                                (__Field::__field11, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedHashFunctions::Ripemd160)
                                }
                                (__Field::__field12, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedHashFunctions::Ripemd256)
                                }
                                (__Field::__field13, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedHashFunctions::Ripemd320)
                                }
                                (__Field::__field14, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedHashFunctions::WhirlPool)
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "md2",
                        "md4",
                        "md5",
                        "sha1",
                        "sha224",
                        "sha256",
                        "sha384",
                        "sha512",
                        "sha512_224",
                        "sha512_256",
                        "ripemd128",
                        "ripemd160",
                        "ripemd256",
                        "ripemd320",
                        "whirlpool",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "SupportedHashFunctions",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                SupportedHashFunctions,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[serde(rename_all = "lowercase")]
        enum SupportedOutputFormat {
            Hex,
            Base64,
            Raw,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SupportedOutputFormat {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 3",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "hex" => _serde::__private::Ok(__Field::__field0),
                                "base64" => _serde::__private::Ok(__Field::__field1),
                                "raw" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"hex" => _serde::__private::Ok(__Field::__field0),
                                b"base64" => _serde::__private::Ok(__Field::__field1),
                                b"raw" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SupportedOutputFormat>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SupportedOutputFormat;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum SupportedOutputFormat",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedOutputFormat::Hex)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedOutputFormat::Base64)
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedOutputFormat::Raw)
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["hex", "base64", "raw"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "SupportedOutputFormat",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                SupportedOutputFormat,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct Params {
            key: String,
            key_format: SupportedFormats,
            hash_function: SupportedHashFunctions,
            output_format: SupportedOutputFormat,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Params {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "key" => _serde::__private::Ok(__Field::__field0),
                                "key_format" => _serde::__private::Ok(__Field::__field1),
                                "hash_function" => _serde::__private::Ok(__Field::__field2),
                                "output_format" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"key" => _serde::__private::Ok(__Field::__field0),
                                b"key_format" => _serde::__private::Ok(__Field::__field1),
                                b"hash_function" => _serde::__private::Ok(__Field::__field2),
                                b"output_format" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Params>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Params;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Params",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Params with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                SupportedFormats,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Params with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                SupportedHashFunctions,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct Params with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                SupportedOutputFormat,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct Params with 4 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Params {
                                key: __field0,
                                key_format: __field1,
                                hash_function: __field2,
                                output_format: __field3,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                SupportedFormats,
                            > = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                SupportedHashFunctions,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<
                                SupportedOutputFormat,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("key"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "key_format",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SupportedFormats,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "hash_function",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SupportedHashFunctions,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "output_format",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SupportedOutputFormat,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("key")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("key_format")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("hash_function")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("output_format")?
                                }
                            };
                            _serde::__private::Ok(Params {
                                key: __field0,
                                key_format: __field1,
                                hash_function: __field2,
                                output_format: __field3,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "key",
                        "key_format",
                        "hash_function",
                        "output_format",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Params",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Params>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct DeserializeMeDaddy {
            input: String,
            params: Params,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                "params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                b"params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Params,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Params> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("params"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Params>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("params")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input", "params"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// Keyed-Hash Message Authentication Codes (HMAC) are a mechanism for message authentication using cryptographic hash functions.
        /// <br><br/>
        /// For more information go [here](https://wikipedia.org/wiki/HMAC)
        /// <br><br/>
        ///
        /// # How to use
        /// \
        /// Send POST requests to /api/HMAC with your data using json payload with this structure
        /// ``` json
        /// {
        ///     "input": string,
        ///     "params": {
        ///         "key": string,
        ///         "key_format": SupportedFormats,
        ///         "hash_function": SupportedHashFunctions,
        ///         "output_format": SupportedOutputFormat
        ///     }
        /// }
        /// ```
        /// #### where
        ///     - SupportedFormat is enum of "binary", "utf8", "hex", "base64", "latin1"
        ///     - SupportedHashFunctions is enum of "md2", "md4", "md5", "sha1", "sha224", "sha256", "sha384", "sha512", "sha512_224", "sha512_256", "ripemd128", "ripemd160", "ripemd256", "ripemd320", "whirlpool"
        ///     - SupportedOutputFormat is enum of "hex", "base64", "raw"
        /// <br/><br/>
        ///
        /// ### Server response have two possible formats
        ///
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
        /// ``` json
        /// {
        ///   "Ok": {
        ///     "hex|base64|uint8array": "string|uint8array"
        ///   }
        /// }
        /// ```
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
        /// ``` json
        /// { "Err": `error message` }
        /// ```
        /// # Examples
        /// ## №1
        /// ``` http
        /// POST /api/HMAC
        ///
        /// {
        ///     "input": "hello",
        ///     "params": {
        ///         "key": "key",
        ///         "key_format": "utf8",
        ///         "hash_function": "ripemd128",
        ///         "output_format": "hex"
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {
        ///   "Ok": {
        ///     "hex": "8ff23128d3b4d93a58d740fe66dc86d4"
        ///   }
        /// }
        /// ```
        /// ## №2
        /// ``` http
        /// POST /api/HMAC
        ///
        /// {
        ///     "input": "deadbeef",
        ///     "params": {
        ///         "key": "ZGVhZGJlZWY=",
        ///         "key_format": "base64",
        ///         "hash_function": "sha256",
        ///         "output_format": "base64"
        ///     }
        /// }
        /// ```
        /// ```http
        /// {
        ///   "Ok": {
        ///     "base64": "fAzUwzhmrZvCxmTkLc0RbvoNTfORtwk9hDkv2NTvvrU"
        ///   }
        /// }
        /// ```
        /// ## №3
        /// ``` http
        /// POST /api/HMAC
        ///
        /// {
        ///     "input": "error",
        ///     "params": {
        ///         "key": "no function",
        ///         "key_format": "latin1",
        ///         "output_format": "uint8array"
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 400 Bad Request
        /// {
        ///   "Err": "Missing field `hash_function`"
        /// }
        /// ```
        pub struct Hmac;
        const NAME: &str = "HMAC";
        const DESCRIPTION_EN: &str = "Keyed-Hash Message Authentication Codes (HMAC) are a mechanism for message authentication using cryptographic hash functions.";
        const DESCRIPTION_RU: &str = "Keyed-Hash Message Authentication Codes (HMAC) — это механизм аутентификации сообщений с использованием криптографических хеш-функций.";
        const INFO_URL: Option<&str> = Some("https://wikipedia.org/wiki/HMAC");
        pub struct HmacInfo {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for HmacInfo {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "HmacInfo",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl HmacInfo {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub mod md2_mod {
        use anyhow::Result;
        use md2::{Digest, Md2};
        use serde::{Deserialize, Serialize};
        use crate::{
            create_info_struct, create_tauri_wrapper, run_operations, utils::to_hex,
            Operation, DOCS_URL,
        };
        pub fn md2(request: &str) -> Result<String, String> {
            run_operations(MD2, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__md2;
        impl Operation<'_, DeserializeMeDaddy> for MD2 {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let input = request.input;
                let mut hasher = Md2::new();
                hasher.update(input);
                let result = hasher.finalize().to_vec();
                Ok(to_hex(&result))
            }
        }
        struct DeserializeMeDaddy {
            input: String,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// The MD2 (Message-Digest 2) algorithm is a cryptographic hash function developed by Ronald Rivest in 1989. The algorithm is optimized for 8-bit computers. Although MD2 is no longer considered secure, even as of 2014, it remains in use in public key infrastructures as part of certificates generated with MD2 and RSA.
        /// <br><br/>
        /// For more information go [here](https://wikipedia.org/wiki/MD2_(cryptography)).
        /// <br><br/>
        ///
        /// # How to use
        /// \
        /// Send POST requests to /api/MD2 with your data using json payload with this structure.
        /// ``` json
        /// {
        ///     "input": string,
        /// }
        /// ```
        /// <br/><br/>
        ///
        /// ### Server response have two possible formats
        ///
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
        /// ``` json
        /// { "Ok": `some answer` }
        /// ```
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
        /// ``` json
        /// { "Err": `error message` }
        /// ```
        /// # Examples
        /// ## №1
        /// ``` http
        /// POST /api/MD2
        ///
        /// {
        ///     "input": "hello",
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {
        ///   "Ok": a946c73e0331af68917d384f7655"
        /// }
        /// ```
        /// ## №2
        /// ``` http
        /// POST /api/MD2
        ///
        /// {
        ///     "input": "hello 123 world",
        /// }
        /// ```
        /// ```http
        /// {
        ///   "Ok": "5a594adcc1d94cf325aa35893e49664"
        /// }
        /// ```
        /// ## №3
        /// ``` http
        /// POST /api/MD2
        ///
        /// {
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 400 Bad Request
        /// {
        ///   "Err": "Missing field `input`"
        /// }
        /// ```
        pub struct MD2;
        const NAME: &str = "MD2";
        const DESCRIPTION_EN: &str = "The MD2 (Message-Digest 2) algorithm is a cryptographic hash function developed by Ronald Rivest in 1989. The algorithm is optimized for 8-bit computers. Although MD2 is no longer considered secure, even as of 2014, it remains in use in public key infrastructures as part of certificates generated with MD2 and RSA.";
        const DESCRIPTION_RU: &str = "Алгоритм MD2 (Message-Digest 2) — это криптографическая хэш-функция, разработанная Рональдом Ривестом в 1989 году. Алгоритм оптимизирован для 8-битных компьютеров. Хотя MD2 больше не считается безопасным, даже с 2014 года он по-прежнему используется в инфраструктурах открытых ключей как часть сертификатов, созданных с помощью MD2 и RSA.";
        const INFO_URL: Option<&str> = Some(
            "https://wikipedia.org/wiki/MD2_(cryptography)",
        );
        pub struct Md2Info {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Md2Info {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "Md2Info",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl Md2Info {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub mod md4_mod {
        use anyhow::Result;
        use md4::{Digest, Md4};
        use serde::{Deserialize, Serialize};
        use crate::{
            create_info_struct, create_tauri_wrapper, run_operations, utils::to_hex,
            Operation, DOCS_URL,
        };
        pub fn md4(request: &str) -> Result<String, String> {
            run_operations(MD4, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__md4;
        impl Operation<'_, DeserializeMeDaddy> for MD4 {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let input = request.input;
                let mut hasher = Md4::new();
                hasher.update(input);
                let result = hasher.finalize().to_vec();
                Ok(to_hex(&result))
            }
        }
        struct DeserializeMeDaddy {
            input: String,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// The MD4 (Message-Digest 4) algorithm is a cryptographic hash function developed by Ronald Rivest in 1990. The digest length is 128 bits. The algorithm has influenced later designs, such as the MD5, SHA-1 and RIPEMD algorithms. The security of MD4 has been severely compromised.
        /// <br><br/>
        /// For more information go [here](https://wikipedia.org/wiki/MD4).
        /// <br><br/>
        ///
        /// # How to use
        /// \
        /// Send POST requests to /api/MD4 with your data using json payload with this structure.
        /// ``` json
        /// {
        ///     "input": string,
        /// }
        /// ```
        /// <br/><br/>
        ///
        /// ### Server response have two possible formats
        ///
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
        /// ``` json
        /// { "Ok": `some answer` }
        /// ```
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
        /// ``` json
        /// { "Err": `error message` }
        /// ```
        /// # Examples
        /// ## №1
        /// ``` http
        /// POST /api/MD4
        ///
        /// {
        ///     "input": "hello",
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {
        ///   "Ok": 866437cb7a794bce2b727acc362ee27"
        /// }
        /// ```
        /// ## №2
        /// ``` http
        /// POST /api/MD4
        ///
        /// {
        ///     "input": "hello 123 world",
        /// }
        /// ```
        /// ```http
        /// {
        ///   "Ok": "a3766d3b55379e5fbeba5e675db2f3"
        /// }
        /// ```
        /// ## №3
        /// ``` http
        /// POST /api/MD4
        ///
        /// {
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 400 Bad Request
        /// {
        ///   "Err": "Missing field `input`"
        /// }
        /// ```
        pub struct MD4;
        const NAME: &str = "MD4";
        const DESCRIPTION_EN: &str = "The MD4 (Message-Digest 4) algorithm is a cryptographic hash function developed by Ronald Rivest in 1990. The digest length is 128 bits. The algorithm has influenced later designs, such as the MD5, SHA-1 and RIPEMD algorithms. The security of MD4 has been severely compromised.";
        const DESCRIPTION_RU: &str = "Алгоритм MD4 (Message-Digest 4) — это криптографическая хэш-функция, разработанная Рональдом Ривестом в 1990 году. Длина дайджеста составляет 128 бит. Алгоритм повлиял на более поздние разработки, такие как алгоритмы MD5, SHA-1 и RIPEMD. Безопасность MD4 была серьезно скомпрометирована».";
        const INFO_URL: Option<&str> = Some("https://wikipedia.org/wiki/MD4");
        pub struct Md4Info {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Md4Info {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "Md4Info",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl Md4Info {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub mod md5_mod {
        use anyhow::Result;
        use md5::{Digest, Md5};
        use serde::{Deserialize, Serialize};
        use crate::{
            create_info_struct, create_tauri_wrapper, run_operations, utils::to_hex,
            Operation, DOCS_URL,
        };
        pub fn md5(request: &str) -> Result<String, String> {
            run_operations(MD5, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__md5;
        impl Operation<'_, DeserializeMeDaddy> for MD5 {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let input = request.input;
                let mut hasher = Md5::new();
                hasher.update(input.as_bytes());
                let result = hasher.finalize().to_vec();
                Ok(to_hex(&result))
            }
        }
        struct DeserializeMeDaddy {
            input: String,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// MD5 (Message-Digest 5) is a widely used hash function. It has been used in a variety of security applications and is also commonly used to check the integrity of files. However, MD5 is not collision resistant, and it isn't suitable for applications like SSL/TLS certificates or digital signatures that rely on this property.
        /// <br><br/>
        /// For more information go [here](https://wikipedia.org/wiki/MD5).
        /// <br><br/>
        ///
        /// # How to use
        /// \
        /// Send POST requests to /api/MD5 with your data using json payload with this structure.
        /// ``` json
        /// {
        ///     "input": string,
        /// }
        /// ```
        /// <br/><br/>
        ///
        /// ### Server response have two possible formats
        ///
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
        /// ``` json
        /// { "Ok": `some answer` }
        /// ```
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
        /// ``` json
        /// { "Err": `error message` }
        /// ```
        /// # Examples
        /// ## №1
        /// ``` http
        /// POST /api/MD5
        ///
        /// {
        ///     "input": "hello",
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {
        ///   "Ok": 5d41402abc4b2a76b9719d911017c592"
        /// }
        /// ```
        /// ## №2
        /// ``` http
        /// POST /api/MD5
        ///
        /// {
        ///     "input": "hello 123 world",
        /// }
        /// ```
        /// ```http
        /// {
        ///   "Ok": "bdcf33e6dce868a580cbc6686476c4e7"
        /// }
        /// ```
        /// ## №3
        /// ``` http
        /// POST /api/MD5
        ///
        /// {
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 400 Bad Request
        /// {
        ///   "Err": "Missing field `input`"
        /// }
        /// ```
        pub struct MD5;
        const NAME: &str = "MD5";
        const DESCRIPTION_EN: &str = "MD5 (Message-Digest 5) is a widely used hash function. It has been used in a variety of security applications, and is also commonly used to check the integrity of files. However, MD5 is not collision resistant and it isn't suitable for applications like SSL/TLS certificates or digital signatures that rely on this property.";
        const DESCRIPTION_RU: &str = "MD5 (Message-Digest 5) — широко используемая хэш-функция. Он использовался в различных приложениях безопасности, а также часто используется для проверки целостности файлов. Однако MD5 не устойчив к коллизиям и не подходит для таких приложений, как SSL/TLS-сертификаты или цифровые сертификаты, которые полагаются на это свойство.";
        const INFO_URL: Option<&str> = Some("https://wikipedia.org/wiki/MD5");
        pub struct Md5Info {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Md5Info {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "Md5Info",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl Md5Info {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub mod reverse_mod {
        use crate::{create_tauri_wrapper, run_operations, Operation};
        use anyhow::Result;
        use serde::Deserialize;
        pub fn reverse(request: &str) -> Result<String, String> {
            run_operations(ReverseString, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__reverse;
        impl Operation<'_, DeserializeMeDaddy> for ReverseString {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let input = request.input;
                Ok(input.chars().rev().collect())
            }
        }
        struct DeserializeMeDaddy {
            input: String,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub struct ReverseString;
    }
    pub mod rsa_decrypt_mod {
        use anyhow::{bail, Result};
        use rsa::{pkcs1::DecodeRsaPrivateKey, Oaep, Pkcs1v15Encrypt, RsaPrivateKey};
        use serde::{Deserialize, Serialize};
        use sha1::Sha1;
        use sha2::{Sha224, Sha256, Sha384, Sha512};
        use sha3::{Sha3_224, Sha3_256, Sha3_384, Sha3_512};
        use crate::{
            create_info_struct, create_me_daddy, create_tauri_wrapper,
            libs::base64::{from_base64, to_base64},
            run_operations, utils::{to_hex, DataRepresentation, DataRepresentationInput},
            Operation, DOCS_URL,
        };
        pub fn rsa_decrypt(request: &str) -> Result<String, String> {
            run_operations(RSADecrypt, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__rsa_decrypt;
        impl Operation<'_, DeserializeMeDaddy> for RSADecrypt {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let (
                    input,
                    pem_key,
                    encrypted_scheme,
                    message_digest_algorithm,
                    output_format,
                ) = (
                    request.input,
                    request.params.private_key,
                    request.params.encrypted_scheme,
                    request.params.message_digest_algorithm,
                    request.params.output_format,
                );
                if match encrypted_scheme {
                    SupportedEncryptionSchemes::RSA_OAEP => true,
                    _ => false,
                } && message_digest_algorithm.is_none()
                {
                    return ::anyhow::__private::Err({
                        let error = ::anyhow::__private::format_err(
                            format_args!("RSA_OAEP must have message digest algorithm"),
                        );
                        error
                    });
                }
                let DataRepresentation::ByteArray(input) = from_base64(
                    input,
                    "",
                    DataRepresentationInput::ByteArray,
                    false,
                    false,
                )? else {
                ::core::panicking::panic("internal error: entered unreachable code") };
                let pem_key: RsaPrivateKey = DecodeRsaPrivateKey::from_pkcs1_pem(
                    &pem_key,
                )?;
                let encrypted_text = match encrypted_scheme {
                    SupportedEncryptionSchemes::RSA_OAEP => {
                        let padding = match message_digest_algorithm.unwrap() {
                            SupportedMessageDigestAlgorithm::SHA1 => Oaep::new::<Sha1>(),
                            SupportedMessageDigestAlgorithm::SHA2_224 => {
                                Oaep::new::<Sha224>()
                            }
                            SupportedMessageDigestAlgorithm::SHA2_256 => {
                                Oaep::new::<Sha256>()
                            }
                            SupportedMessageDigestAlgorithm::SHA2_384 => {
                                Oaep::new::<Sha384>()
                            }
                            SupportedMessageDigestAlgorithm::SHA2_512 => {
                                Oaep::new::<Sha512>()
                            }
                            SupportedMessageDigestAlgorithm::SHA3_224 => {
                                Oaep::new::<Sha3_224>()
                            }
                            SupportedMessageDigestAlgorithm::SHA3_256 => {
                                Oaep::new::<Sha3_256>()
                            }
                            SupportedMessageDigestAlgorithm::SHA3_384 => {
                                Oaep::new::<Sha3_384>()
                            }
                            SupportedMessageDigestAlgorithm::SHA3_512 => {
                                Oaep::new::<Sha3_512>()
                            }
                        };
                        pem_key.decrypt(padding, &input)
                    }
                    SupportedEncryptionSchemes::RSA_AES_PKCS1_V1_5 => {
                        pem_key.decrypt(Pkcs1v15Encrypt, &input)
                    }
                }?;
                Ok(
                    match output_format {
                        SupportedOutputFormat::Hex => to_hex(&encrypted_text),
                        SupportedOutputFormat::Base64 => {
                            to_base64(&encrypted_text, None)?
                        }
                        SupportedOutputFormat::Uint8Array => {
                            String::from_utf8_lossy(&encrypted_text).to_string()
                        }
                    },
                )
            }
        }
        #[allow(non_camel_case_types)]
        enum SupportedEncryptionSchemes {
            #[serde(rename = "oaep")]
            RSA_OAEP,
            #[serde(rename = "pkcs1_v15")]
            RSA_AES_PKCS1_V1_5,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SupportedEncryptionSchemes {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "oaep" => _serde::__private::Ok(__Field::__field0),
                                "pkcs1_v15" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"oaep" => _serde::__private::Ok(__Field::__field0),
                                b"pkcs1_v15" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<
                            SupportedEncryptionSchemes,
                        >,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SupportedEncryptionSchemes;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum SupportedEncryptionSchemes",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedEncryptionSchemes::RSA_OAEP)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(
                                        SupportedEncryptionSchemes::RSA_AES_PKCS1_V1_5,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["oaep", "pkcs1_v15"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "SupportedEncryptionSchemes",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                SupportedEncryptionSchemes,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[allow(non_camel_case_types)]
        #[serde(rename_all = "lowercase")]
        enum SupportedMessageDigestAlgorithm {
            SHA1,
            SHA2_224,
            SHA2_256,
            SHA2_384,
            SHA2_512,
            SHA3_224,
            SHA3_256,
            SHA3_384,
            SHA3_512,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SupportedMessageDigestAlgorithm {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __field8,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                8u64 => _serde::__private::Ok(__Field::__field8),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 9",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "sha1" => _serde::__private::Ok(__Field::__field0),
                                "sha2_224" => _serde::__private::Ok(__Field::__field1),
                                "sha2_256" => _serde::__private::Ok(__Field::__field2),
                                "sha2_384" => _serde::__private::Ok(__Field::__field3),
                                "sha2_512" => _serde::__private::Ok(__Field::__field4),
                                "sha3_224" => _serde::__private::Ok(__Field::__field5),
                                "sha3_256" => _serde::__private::Ok(__Field::__field6),
                                "sha3_384" => _serde::__private::Ok(__Field::__field7),
                                "sha3_512" => _serde::__private::Ok(__Field::__field8),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"sha1" => _serde::__private::Ok(__Field::__field0),
                                b"sha2_224" => _serde::__private::Ok(__Field::__field1),
                                b"sha2_256" => _serde::__private::Ok(__Field::__field2),
                                b"sha2_384" => _serde::__private::Ok(__Field::__field3),
                                b"sha2_512" => _serde::__private::Ok(__Field::__field4),
                                b"sha3_224" => _serde::__private::Ok(__Field::__field5),
                                b"sha3_256" => _serde::__private::Ok(__Field::__field6),
                                b"sha3_384" => _serde::__private::Ok(__Field::__field7),
                                b"sha3_512" => _serde::__private::Ok(__Field::__field8),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<
                            SupportedMessageDigestAlgorithm,
                        >,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SupportedMessageDigestAlgorithm;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum SupportedMessageDigestAlgorithm",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedMessageDigestAlgorithm::SHA1)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(
                                        SupportedMessageDigestAlgorithm::SHA2_224,
                                    )
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(
                                        SupportedMessageDigestAlgorithm::SHA2_256,
                                    )
                                }
                                (__Field::__field3, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(
                                        SupportedMessageDigestAlgorithm::SHA2_384,
                                    )
                                }
                                (__Field::__field4, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(
                                        SupportedMessageDigestAlgorithm::SHA2_512,
                                    )
                                }
                                (__Field::__field5, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(
                                        SupportedMessageDigestAlgorithm::SHA3_224,
                                    )
                                }
                                (__Field::__field6, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(
                                        SupportedMessageDigestAlgorithm::SHA3_256,
                                    )
                                }
                                (__Field::__field7, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(
                                        SupportedMessageDigestAlgorithm::SHA3_384,
                                    )
                                }
                                (__Field::__field8, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(
                                        SupportedMessageDigestAlgorithm::SHA3_512,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "sha1",
                        "sha2_224",
                        "sha2_256",
                        "sha2_384",
                        "sha2_512",
                        "sha3_224",
                        "sha3_256",
                        "sha3_384",
                        "sha3_512",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "SupportedMessageDigestAlgorithm",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                SupportedMessageDigestAlgorithm,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[serde(rename_all = "lowercase")]
        enum SupportedOutputFormat {
            Hex,
            Base64,
            Uint8Array,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SupportedOutputFormat {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 3",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "hex" => _serde::__private::Ok(__Field::__field0),
                                "base64" => _serde::__private::Ok(__Field::__field1),
                                "uint8array" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"hex" => _serde::__private::Ok(__Field::__field0),
                                b"base64" => _serde::__private::Ok(__Field::__field1),
                                b"uint8array" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SupportedOutputFormat>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SupportedOutputFormat;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum SupportedOutputFormat",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedOutputFormat::Hex)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedOutputFormat::Base64)
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedOutputFormat::Uint8Array)
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "hex",
                        "base64",
                        "uint8array",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "SupportedOutputFormat",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                SupportedOutputFormat,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct Params {
            #[serde(rename = "pem_key")]
            private_key: String,
            #[serde(rename = "scheme")]
            encrypted_scheme: SupportedEncryptionSchemes,
            #[serde(rename = "digest_alg")]
            message_digest_algorithm: Option<SupportedMessageDigestAlgorithm>,
            output_format: SupportedOutputFormat,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Params {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "pem_key" => _serde::__private::Ok(__Field::__field0),
                                "scheme" => _serde::__private::Ok(__Field::__field1),
                                "digest_alg" => _serde::__private::Ok(__Field::__field2),
                                "output_format" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"pem_key" => _serde::__private::Ok(__Field::__field0),
                                b"scheme" => _serde::__private::Ok(__Field::__field1),
                                b"digest_alg" => _serde::__private::Ok(__Field::__field2),
                                b"output_format" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Params>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Params;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Params",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Params with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                SupportedEncryptionSchemes,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Params with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                Option<SupportedMessageDigestAlgorithm>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct Params with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                SupportedOutputFormat,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct Params with 4 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Params {
                                private_key: __field0,
                                encrypted_scheme: __field1,
                                message_digest_algorithm: __field2,
                                output_format: __field3,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                SupportedEncryptionSchemes,
                            > = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                Option<SupportedMessageDigestAlgorithm>,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<
                                SupportedOutputFormat,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "pem_key",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("scheme"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SupportedEncryptionSchemes,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "digest_alg",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<SupportedMessageDigestAlgorithm>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "output_format",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SupportedOutputFormat,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("pem_key")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("scheme")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("digest_alg")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("output_format")?
                                }
                            };
                            _serde::__private::Ok(Params {
                                private_key: __field0,
                                encrypted_scheme: __field1,
                                message_digest_algorithm: __field2,
                                output_format: __field3,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "pem_key",
                        "scheme",
                        "digest_alg",
                        "output_format",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Params",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Params>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct DeserializeMeDaddy {
            input: String,
            params: Params,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                "params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                b"params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Params,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Params> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("params"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Params>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("params")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input", "params"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// Decrypt a message with a PEM encoded RSA private key.
        /// <br><br/>
        /// For more information go [here](https://wikipedia.org/wiki/RSA_(cryptosystem))
        /// <br><br/>
        ///
        /// # How to use
        /// \
        /// Send POST requests to /api/RSADecrypt with your data using json payload with this structure
        /// ``` json
        /// {
        ///     "input": base64,
        ///     "params": {
        ///         "pem_key": PEM,
        ///         "scheme": SupportedEncryptionSchemes,
        ///         "digest_alg": Option<SupportedMessageDigestAlgorithm>
        ///         "output_format": SupportedOutputFormat
        ///     }
        /// }
        /// ```
        /// #### where
        ///     - base64 is base64 encoded string
        ///     - PEM is pem encoded RSA public key
        ///     - SupportedEncryptionSchemes is enum of "oaep" and "pkcs1_v15"
        ///     - Option<SupportedMessageDigestAlgorithm> is optional enum of "sha1", "sha2-224", "sha2-256", "sha2-384", "sha2-512", "sha3-224", "sha3-256", "sha3-384", "sha3-512"
        ///     - SupportedOutputFormat is enum of "hex", "base64", "uint8array"
        /// <br/><br/>
        ///
        /// ### Server response have two possible formats
        ///
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
        /// ``` json
        /// {
        ///   "Ok": {
        ///     "hex|base64|uint8array": "string|uint8array"
        ///   }
        /// }
        /// ```
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
        /// ``` json
        /// { "Err": `error message` }
        /// ```
        /// # Examples
        /// ## №1
        /// ``` http
        /// POST /api/RSADecrypt
        ///
        /// {
        ///     "input": {base64 encoded input},
        ///     "params": {
        ///         "pub_key": {PEM encoded key},
        ///         "scheme": "oaep",
        ///         "digest_alg": "sha2_256",
        ///         "output_format": "hex"
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {
        ///   "Ok": {
        ///     "hex": "6e6576657220676f6e6e612e2e"
        ///   }
        /// }
        /// ```
        /// ## №2
        /// ``` http
        /// POST /api/RSADecrypt
        ///
        /// {
        ///     "input": {base64 encoded input},
        ///     "params": {
        ///         "pub_key": {PEM encoded key},
        ///         "scheme": "pkcs1_v15",
        ///         "output_format": "base64"
        ///     }
        /// }
        /// ```
        /// ```http
        /// {
        ///   "Ok": {
        ///     "base64": "aGVsbG8gd29ybGQK"
        ///   }
        /// }
        /// ```
        /// ## №3
        /// ``` http
        /// POST /api/RSADecrypt
        ///
        /// {
        ///     "input": "error",
        ///     "params": {
        ///         "scheme": "pkcs1_v15",
        ///         "output_format": "uint8array"
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 400 Bad Request
        /// {
        ///   "Err": "Missing field `pem_key`"
        /// }
        /// ```
        pub struct RSADecrypt;
        const NAME: &str = "RSADecrypt";
        const DESCRIPTION_EN: &str = "Decrypt a message with a PEM encoded RSA private key.";
        const DESCRIPTION_RU: &str = "Дешифрует сообщение с помощью приватного ключа RSA с кодировкой PEM.";
        const INFO_URL: Option<&str> = Some(
            "https://wikipedia.org/wiki/RSA_(cryptosystem)",
        );
        pub struct RSADecryptInfo {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for RSADecryptInfo {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "RSADecryptInfo",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl RSADecryptInfo {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub mod rsa_encrypt_mod {
        use anyhow::{bail, Result};
        use rsa::{pkcs1::DecodeRsaPublicKey, Oaep, Pkcs1v15Encrypt, RsaPublicKey};
        use serde::{Deserialize, Serialize};
        use sha1::Sha1;
        use sha2::{Sha224, Sha256, Sha384, Sha512};
        use sha3::{Sha3_224, Sha3_256, Sha3_384, Sha3_512};
        use crate::{
            create_info_struct, create_me_daddy, create_tauri_wrapper,
            libs::base64::to_base64, run_operations, utils::to_hex, Operation, DOCS_URL,
        };
        pub fn rsa_encrypt(request: &str) -> Result<String, String> {
            run_operations(RSAEncrypt, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__rsa_encrypt;
        impl Operation<'_, DeserializeMeDaddy> for RSAEncrypt {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let (
                    input,
                    public_key,
                    encrypted_scheme,
                    message_digest_algorithm,
                    output_format,
                ) = (
                    request.input,
                    request.params.public_key,
                    request.params.encrypted_scheme,
                    request.params.message_digest_algorithm,
                    request.params.output_format,
                );
                if match encrypted_scheme {
                    SupportedEncryptionSchemes::RSA_OAEP => true,
                    _ => false,
                } && message_digest_algorithm.is_none()
                {
                    return ::anyhow::__private::Err({
                        let error = ::anyhow::__private::format_err(
                            format_args!("RSA_OAEP must have message digest algorithm"),
                        );
                        error
                    });
                }
                let pub_key = RsaPublicKey::from_pkcs1_pem(&public_key)?;
                let mut rng = rand::thread_rng();
                let encrypted_text = match encrypted_scheme {
                    SupportedEncryptionSchemes::RSA_OAEP => {
                        let padding = match message_digest_algorithm.unwrap() {
                            SupportedMessageDigestAlgorithm::SHA1 => Oaep::new::<Sha1>(),
                            SupportedMessageDigestAlgorithm::SHA2_224 => {
                                Oaep::new::<Sha224>()
                            }
                            SupportedMessageDigestAlgorithm::SHA2_256 => {
                                Oaep::new::<Sha256>()
                            }
                            SupportedMessageDigestAlgorithm::SHA2_384 => {
                                Oaep::new::<Sha384>()
                            }
                            SupportedMessageDigestAlgorithm::SHA2_512 => {
                                Oaep::new::<Sha512>()
                            }
                            SupportedMessageDigestAlgorithm::SHA3_224 => {
                                Oaep::new::<Sha3_224>()
                            }
                            SupportedMessageDigestAlgorithm::SHA3_256 => {
                                Oaep::new::<Sha3_256>()
                            }
                            SupportedMessageDigestAlgorithm::SHA3_384 => {
                                Oaep::new::<Sha3_384>()
                            }
                            SupportedMessageDigestAlgorithm::SHA3_512 => {
                                Oaep::new::<Sha3_512>()
                            }
                        };
                        pub_key.encrypt(&mut rng, padding, input.as_bytes())
                    }
                    SupportedEncryptionSchemes::RSA_AES_PKCS1_V1_5 => {
                        pub_key.encrypt(&mut rng, Pkcs1v15Encrypt, input.as_bytes())
                    }
                }?;
                Ok(
                    match output_format {
                        SupportedOutputFormat::Hex => to_hex(&encrypted_text),
                        SupportedOutputFormat::Base64 => {
                            to_base64(&encrypted_text, None)?
                        }
                        SupportedOutputFormat::Raw => {
                            String::from_utf8_lossy(&encrypted_text).to_string()
                        }
                    },
                )
            }
        }
        #[allow(non_camel_case_types)]
        enum SupportedEncryptionSchemes {
            #[serde(rename = "oaep")]
            RSA_OAEP,
            #[serde(rename = "pkcs1_v15")]
            RSA_AES_PKCS1_V1_5,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SupportedEncryptionSchemes {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "oaep" => _serde::__private::Ok(__Field::__field0),
                                "pkcs1_v15" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"oaep" => _serde::__private::Ok(__Field::__field0),
                                b"pkcs1_v15" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<
                            SupportedEncryptionSchemes,
                        >,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SupportedEncryptionSchemes;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum SupportedEncryptionSchemes",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedEncryptionSchemes::RSA_OAEP)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(
                                        SupportedEncryptionSchemes::RSA_AES_PKCS1_V1_5,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["oaep", "pkcs1_v15"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "SupportedEncryptionSchemes",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                SupportedEncryptionSchemes,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[allow(non_camel_case_types)]
        #[serde(rename_all = "lowercase")]
        enum SupportedMessageDigestAlgorithm {
            SHA1,
            SHA2_224,
            SHA2_256,
            SHA2_384,
            SHA2_512,
            SHA3_224,
            SHA3_256,
            SHA3_384,
            SHA3_512,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SupportedMessageDigestAlgorithm {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __field8,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                8u64 => _serde::__private::Ok(__Field::__field8),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 9",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "sha1" => _serde::__private::Ok(__Field::__field0),
                                "sha2_224" => _serde::__private::Ok(__Field::__field1),
                                "sha2_256" => _serde::__private::Ok(__Field::__field2),
                                "sha2_384" => _serde::__private::Ok(__Field::__field3),
                                "sha2_512" => _serde::__private::Ok(__Field::__field4),
                                "sha3_224" => _serde::__private::Ok(__Field::__field5),
                                "sha3_256" => _serde::__private::Ok(__Field::__field6),
                                "sha3_384" => _serde::__private::Ok(__Field::__field7),
                                "sha3_512" => _serde::__private::Ok(__Field::__field8),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"sha1" => _serde::__private::Ok(__Field::__field0),
                                b"sha2_224" => _serde::__private::Ok(__Field::__field1),
                                b"sha2_256" => _serde::__private::Ok(__Field::__field2),
                                b"sha2_384" => _serde::__private::Ok(__Field::__field3),
                                b"sha2_512" => _serde::__private::Ok(__Field::__field4),
                                b"sha3_224" => _serde::__private::Ok(__Field::__field5),
                                b"sha3_256" => _serde::__private::Ok(__Field::__field6),
                                b"sha3_384" => _serde::__private::Ok(__Field::__field7),
                                b"sha3_512" => _serde::__private::Ok(__Field::__field8),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<
                            SupportedMessageDigestAlgorithm,
                        >,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SupportedMessageDigestAlgorithm;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum SupportedMessageDigestAlgorithm",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedMessageDigestAlgorithm::SHA1)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(
                                        SupportedMessageDigestAlgorithm::SHA2_224,
                                    )
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(
                                        SupportedMessageDigestAlgorithm::SHA2_256,
                                    )
                                }
                                (__Field::__field3, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(
                                        SupportedMessageDigestAlgorithm::SHA2_384,
                                    )
                                }
                                (__Field::__field4, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(
                                        SupportedMessageDigestAlgorithm::SHA2_512,
                                    )
                                }
                                (__Field::__field5, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(
                                        SupportedMessageDigestAlgorithm::SHA3_224,
                                    )
                                }
                                (__Field::__field6, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(
                                        SupportedMessageDigestAlgorithm::SHA3_256,
                                    )
                                }
                                (__Field::__field7, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(
                                        SupportedMessageDigestAlgorithm::SHA3_384,
                                    )
                                }
                                (__Field::__field8, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(
                                        SupportedMessageDigestAlgorithm::SHA3_512,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "sha1",
                        "sha2_224",
                        "sha2_256",
                        "sha2_384",
                        "sha2_512",
                        "sha3_224",
                        "sha3_256",
                        "sha3_384",
                        "sha3_512",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "SupportedMessageDigestAlgorithm",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                SupportedMessageDigestAlgorithm,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[serde(rename_all = "lowercase")]
        enum SupportedOutputFormat {
            Hex,
            Base64,
            Raw,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SupportedOutputFormat {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 3",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "hex" => _serde::__private::Ok(__Field::__field0),
                                "base64" => _serde::__private::Ok(__Field::__field1),
                                "raw" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"hex" => _serde::__private::Ok(__Field::__field0),
                                b"base64" => _serde::__private::Ok(__Field::__field1),
                                b"raw" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SupportedOutputFormat>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SupportedOutputFormat;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum SupportedOutputFormat",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedOutputFormat::Hex)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedOutputFormat::Base64)
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedOutputFormat::Raw)
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["hex", "base64", "raw"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "SupportedOutputFormat",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                SupportedOutputFormat,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct Params {
            #[serde(rename = "pub_key")]
            public_key: String,
            #[serde(rename = "scheme")]
            encrypted_scheme: SupportedEncryptionSchemes,
            #[serde(rename = "digest_alg")]
            message_digest_algorithm: Option<SupportedMessageDigestAlgorithm>,
            output_format: SupportedOutputFormat,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Params {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "pub_key" => _serde::__private::Ok(__Field::__field0),
                                "scheme" => _serde::__private::Ok(__Field::__field1),
                                "digest_alg" => _serde::__private::Ok(__Field::__field2),
                                "output_format" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"pub_key" => _serde::__private::Ok(__Field::__field0),
                                b"scheme" => _serde::__private::Ok(__Field::__field1),
                                b"digest_alg" => _serde::__private::Ok(__Field::__field2),
                                b"output_format" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Params>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Params;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Params",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Params with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                SupportedEncryptionSchemes,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Params with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                Option<SupportedMessageDigestAlgorithm>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct Params with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                SupportedOutputFormat,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct Params with 4 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Params {
                                public_key: __field0,
                                encrypted_scheme: __field1,
                                message_digest_algorithm: __field2,
                                output_format: __field3,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                SupportedEncryptionSchemes,
                            > = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                Option<SupportedMessageDigestAlgorithm>,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<
                                SupportedOutputFormat,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "pub_key",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("scheme"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SupportedEncryptionSchemes,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "digest_alg",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<SupportedMessageDigestAlgorithm>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "output_format",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SupportedOutputFormat,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("pub_key")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("scheme")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("digest_alg")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("output_format")?
                                }
                            };
                            _serde::__private::Ok(Params {
                                public_key: __field0,
                                encrypted_scheme: __field1,
                                message_digest_algorithm: __field2,
                                output_format: __field3,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "pub_key",
                        "scheme",
                        "digest_alg",
                        "output_format",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Params",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Params>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct DeserializeMeDaddy {
            input: String,
            params: Params,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                "params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                b"params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Params,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Params> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("params"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Params>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("params")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input", "params"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// Encrypt a message with a PEM encoded RSA public key.
        /// <br><br/>
        /// For more information go [here](https://wikipedia.org/wiki/RSA_(cryptosystem))
        /// <br><br/>
        ///
        /// # How to use
        /// \
        /// Send POST requests to /api/RSAEncrypt with your data using json payload with this structure
        /// ``` json
        /// {
        ///     "input": string,
        ///     "params": {
        ///         "pub_key": PEM,
        ///         "scheme": SupportedEncryptionSchemes,
        ///         "digest_alg": Option<SupportedMessageDigestAlgorithm>
        ///         "output_format": SupportedOutputFormat
        ///     }
        /// }
        /// ```
        /// #### where
        ///     - PEM is pem encoded RSA public key
        ///     - SupportedEncryptionSchemes is enum of "oaep" and "pkcs1_v15"
        ///     - Option<SupportedMessageDigestAlgorithm> is optional enum of "sha1", "sha2-224", "sha2-256", "sha2-384", "sha2-512", "sha3-224", "sha3-256", "sha3-384", "sha3-512"
        ///     - SupportedOutputFormat is enum of "hex", "base64", "uint8array"
        /// <br/><br/>
        ///
        /// ### Server response have two possible formats
        ///
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
        /// ``` json
        /// {
        ///   "Ok": {
        ///     "hex|base64|uint8array": "string|uint8array"
        ///   }
        /// }
        /// ```
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
        /// ``` json
        /// { "Err": `error message` }
        /// ```
        /// # Examples
        /// ## №1
        /// ``` http
        /// POST /api/RSAEncrypt
        ///
        /// {
        ///     "input": "hello",
        ///     "params": {
        ///         "pub_key": {PEM encoded key},
        ///         "scheme": "oaep",
        ///         "digest_alg": "sha2_256",
        ///         "output_format": "hex"
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {
        ///   "Ok": {
        ///     "hex": "66bbd6ab6373e0564c4e7adbbc9dd27a9ca4a0857254c7ea00d62a5cbd21eaeacd9684bbcc7a7922260ea686187f41eb6befe117f09c46343e57260dc1f4b4d80ccc0cfc87f2d0ce836ee6a7326a94f2ace2ca1f76c3139966237fc97c3abe8251ef4733266855f3d5174b1796524ce5f419d25d79b856113517c5c933f2d1dce37bd0d5783b384ee9c17b2562a34da964bff799d6152a163f0e9455f1fe5f488c02c46373be3b4cf388b6a04aa4354fd094918b7d98f3351b6e8d575816e542a72d03085cddd9f7d79f886304934a7474ce2c019382cf217b632e170ed286b9ee0f956ff12f93e64af4c20cae4a69c91a356e4ffbce6531"
        ///   }
        /// }
        /// ```
        /// ## №2
        /// ``` http
        /// POST /api/RSAEncrypt
        ///
        /// {
        ///     "input": "hello",
        ///     "params": {
        ///         "pub_key": {PEM encoded key},
        ///         "scheme": "pkcs1_v15",
        ///         "output_format": "base64"
        ///     }
        /// }
        /// ```
        /// ```http
        /// {
        ///   "Ok": {
        ///     "base64": "kip548Yss3HwbrlOJHwtVhRn6tOfEyFcO5UQ4Otgx4HLI2m89mOTEgeo6qH8tkgPfZsno8aTHXaXH+UUoV3WnNF5Q5Y0/Fql2APQYQ3dsaU3sdnzDR/dX4yaGhfOZ3hhbalo509mbqR5kz27VcAhgmXPZIKHGTwjra/hjYhyP3uWqxw/svsxPyIZqOz8Y0qb84GIjNk0+5cFRAJMuV6+fpme5UyApHpaw4GVY9XxiNKECkQ+etK0jr/aclLjiU7I60Qayrhstlf10l8SYgRtmvs6TTVmYYGbRDwLNe9CqPCaqGUsPQpLtP8GVVEKE7M/RNemQgKfvZIfj/N6b3W58g="
        ///   }
        /// }
        /// ```
        /// ## №3
        /// ``` http
        /// POST /api/RSAEncrypt
        ///
        /// {
        ///     "input": "error",
        ///     "params": {
        ///         "scheme": "pkcs1_v15",
        ///         "output_format": "uint8array"
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 400 Bad Request
        /// {
        ///   "Err": "Missing field `pub_key`"
        /// }
        /// ```
        pub struct RSAEncrypt;
        const NAME: &str = "RSAEncrypt";
        const DESCRIPTION_EN: &str = "Encrypt a message with a PEM encoded RSA public key.";
        const DESCRIPTION_RU: &str = "Шифрует сообщение с помощью открытого ключа RSA с кодировкой PEM.";
        const INFO_URL: Option<&str> = Some(
            "https://wikipedia.org/wiki/RSA_(cryptosystem)",
        );
        pub struct RSAEncryptInfo {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for RSAEncryptInfo {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "RSAEncryptInfo",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl RSAEncryptInfo {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    mod scrypt_mod {
        use crate::{
            create_me_daddy, utils::{convert_to_byte_array, SupportedFormats},
            Operation,
        };
        use anyhow::Result;
        use scrypt::password_hash::SaltString;
        use scrypt::{password_hash::PasswordHasher, Scrypt as MScrypt};
        use serde::{Deserialize, Serialize};
        impl Operation<'_, DeserializeMeDaddy> for Scrypt {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let (
                    input,
                    Params {
                        salt,
                        salt_format,
                        iterations,
                        memory,
                        parallelism,
                        key_length,
                    },
                ) = (request.input, request.params);
                let salt = convert_to_byte_array(&salt, &salt_format)?;
                let salt = SaltString::encode_b64(&salt)?;
                let params = scrypt::Params::new(
                    memory,
                    iterations,
                    parallelism,
                    key_length,
                )?;
                let password_hash = MScrypt
                    .hash_password_customized(
                        input.as_bytes(),
                        None,
                        None,
                        params,
                        &salt,
                    )?;
                {
                    ::std::io::_print(format_args!("{0}\n", password_hash));
                };
                Ok(password_hash.to_string())
            }
        }
        struct Params {
            salt: String,
            salt_format: SupportedFormats,
            iterations: u32,
            memory: u8,
            parallelism: u32,
            key_length: usize,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Params {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "Params",
                        false as usize + 1 + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "salt",
                        &self.salt,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "salt_format",
                        &self.salt_format,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "iterations",
                        &self.iterations,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "memory",
                        &self.memory,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "parallelism",
                        &self.parallelism,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "key_length",
                        &self.key_length,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Params {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "salt" => _serde::__private::Ok(__Field::__field0),
                                "salt_format" => _serde::__private::Ok(__Field::__field1),
                                "iterations" => _serde::__private::Ok(__Field::__field2),
                                "memory" => _serde::__private::Ok(__Field::__field3),
                                "parallelism" => _serde::__private::Ok(__Field::__field4),
                                "key_length" => _serde::__private::Ok(__Field::__field5),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"salt" => _serde::__private::Ok(__Field::__field0),
                                b"salt_format" => _serde::__private::Ok(__Field::__field1),
                                b"iterations" => _serde::__private::Ok(__Field::__field2),
                                b"memory" => _serde::__private::Ok(__Field::__field3),
                                b"parallelism" => _serde::__private::Ok(__Field::__field4),
                                b"key_length" => _serde::__private::Ok(__Field::__field5),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Params>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Params;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Params",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Params with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                SupportedFormats,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Params with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                u32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct Params with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                u8,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct Params with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                u32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct Params with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match _serde::de::SeqAccess::next_element::<
                                usize,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct Params with 6 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Params {
                                salt: __field0,
                                salt_format: __field1,
                                iterations: __field2,
                                memory: __field3,
                                parallelism: __field4,
                                key_length: __field5,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                SupportedFormats,
                            > = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<u32> = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<u8> = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<u32> = _serde::__private::None;
                            let mut __field5: _serde::__private::Option<usize> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("salt"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "salt_format",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SupportedFormats,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "iterations",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("memory"),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "parallelism",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "key_length",
                                                ),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("salt")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("salt_format")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("iterations")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("memory")?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("parallelism")?
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("key_length")?
                                }
                            };
                            _serde::__private::Ok(Params {
                                salt: __field0,
                                salt_format: __field1,
                                iterations: __field2,
                                memory: __field3,
                                parallelism: __field4,
                                key_length: __field5,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "salt",
                        "salt_format",
                        "iterations",
                        "memory",
                        "parallelism",
                        "key_length",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Params",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Params>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        enum SaltFormats {
            Hex,
            Base64,
            UTF8,
            Latin1,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for SaltFormats {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        SaltFormats::Hex => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "SaltFormats",
                                0u32,
                                "Hex",
                            )
                        }
                        SaltFormats::Base64 => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "SaltFormats",
                                1u32,
                                "Base64",
                            )
                        }
                        SaltFormats::UTF8 => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "SaltFormats",
                                2u32,
                                "UTF8",
                            )
                        }
                        SaltFormats::Latin1 => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "SaltFormats",
                                3u32,
                                "Latin1",
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SaltFormats {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 4",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Hex" => _serde::__private::Ok(__Field::__field0),
                                "Base64" => _serde::__private::Ok(__Field::__field1),
                                "UTF8" => _serde::__private::Ok(__Field::__field2),
                                "Latin1" => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Hex" => _serde::__private::Ok(__Field::__field0),
                                b"Base64" => _serde::__private::Ok(__Field::__field1),
                                b"UTF8" => _serde::__private::Ok(__Field::__field2),
                                b"Latin1" => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SaltFormats>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SaltFormats;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum SaltFormats",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SaltFormats::Hex)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SaltFormats::Base64)
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SaltFormats::UTF8)
                                }
                                (__Field::__field3, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SaltFormats::Latin1)
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "Hex",
                        "Base64",
                        "UTF8",
                        "Latin1",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "SaltFormats",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<SaltFormats>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct DeserializeMeDaddy {
            input: String,
            params: Params,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                "params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                b"params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Params,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Params> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("params"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Params>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("params")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input", "params"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub struct Scrypt;
    }
    pub mod sha1_mod {
        use anyhow::Result;
        use serde::{Deserialize, Serialize};
        use sha1::{Digest, Sha1};
        use crate::{
            create_info_struct, create_tauri_wrapper, run_operations, utils::to_hex,
            Operation, DOCS_URL,
        };
        pub fn sha1(request: &str) -> Result<String, String> {
            run_operations(SHA1, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__sha1;
        impl Operation<'_, DeserializeMeDaddy> for SHA1 {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let input = request.input;
                let mut hasher = Sha1::new();
                hasher.update(input.as_bytes());
                let result = hasher.finalize().to_vec();
                Ok(to_hex(&result))
            }
        }
        pub struct DeserializeMeDaddy {
            input: String,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// The SHA (Secure Hash Algorithm) hash functions were designed by the NSA. SHA-1 is the most established of the existing SHA hash functions, and it is used in a variety of security applications and protocols. However, SHA-1's collision resistance has been weakening as new attacks are discovered or improved.
        /// <br><br/>
        /// For more information go [here](https://wikipedia.org/wiki/SHA-1).
        /// <br><br/>
        ///
        /// # How to use
        /// \
        /// Send POST requests to /api/SHA1 with your data using json payload with this structure.
        /// ``` json
        /// {
        ///     "input": string,
        /// }
        /// ```
        /// <br/><br/>
        ///
        /// ### Server response have two possible formats
        ///
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
        /// ``` json
        /// { "Ok": `some answer` }
        /// ```
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
        /// ``` json
        /// { "Err": `error message` }
        /// ```
        /// # Examples
        /// ## №1
        /// ``` http
        /// POST /api/SHA1
        ///
        /// {
        ///     "input": "hello",
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {
        ///   "Ok": aaf4c61ddcc5e8a2dabedef3b482cd9aea9434d"
        /// }
        /// ```
        /// ## №2
        /// ``` http
        /// POST /api/SHA1
        ///
        /// {
        ///     "input": "hello 123 world",
        /// }
        /// ```
        /// ```http
        /// {
        ///   "Ok": "9bb51a436f8faadcbbd793cc96fb1ab38b281"
        /// }
        /// ```
        /// ## №3
        /// ``` http
        /// POST /api/SHA1
        ///
        /// {
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 400 Bad Request
        /// {
        ///   "Err": "Missing field `input`"
        /// }
        /// ```
        pub struct SHA1;
        const NAME: &str = "SHA1";
        const DESCRIPTION_EN: &str = "The SHA (Secure Hash Algorithm) hash functions were designed by the NSA. SHA-1 is the most established of the existing SHA hash functions and it is used in a variety of security applications and protocols. However, SHA-1's collision resistance has been weakening as new attacks are discovered or improved.";
        const DESCRIPTION_RU: &str = "Хэш-функции SHA (Secure Hash Algorithm) были разработаны АНБ. SHA-1 самая распространенная из существующих хеш-функций SHA. Она используется в различных приложениях и протоколах безопасности. Однако устойчивость SHA-1 к коллизиям ослабевает по мере обнаружения или улучшения новых атак.";
        const INFO_URL: Option<&str> = Some("https://wikipedia.org/wiki/SHA-1");
        pub struct Sha1Info {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Sha1Info {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "Sha1Info",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl Sha1Info {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub mod sha2_mod {
        use anyhow::Result;
        use serde::{Deserialize, Serialize};
        use sha2::{Digest, Sha224, Sha256, Sha384, Sha512, Sha512_224, Sha512_256};
        use crate::{
            create_info_struct, create_me_daddy, create_tauri_wrapper, run_operations,
            utils::to_hex, Operation, DOCS_URL,
        };
        pub fn sha2(request: &str) -> Result<String, String> {
            run_operations(SHA2, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__sha2;
        impl Operation<'_, DeserializeMeDaddy> for SHA2 {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let (input, size) = (request.input, request.params.size);
                let result = match size {
                    SupportedSHA2Size::SHA224 => {
                        let mut hasher = Sha224::new();
                        hasher.update(input);
                        to_hex(&hasher.finalize()[..])
                    }
                    SupportedSHA2Size::SHA256 => {
                        let mut hasher = Sha256::new();
                        hasher.update(input);
                        to_hex(&hasher.finalize()[..])
                    }
                    SupportedSHA2Size::SHA384 => {
                        let mut hasher = Sha384::new();
                        hasher.update(input);
                        to_hex(&hasher.finalize()[..])
                    }
                    SupportedSHA2Size::SHA512 => {
                        let mut hasher = Sha512::new();
                        hasher.update(input);
                        to_hex(&hasher.finalize()[..])
                    }
                    SupportedSHA2Size::SHA512_224 => {
                        let mut hasher = Sha512_224::new();
                        hasher.update(input);
                        to_hex(&hasher.finalize()[..])
                    }
                    SupportedSHA2Size::SHA512_256 => {
                        let mut hasher = Sha512_256::new();
                        hasher.update(input);
                        to_hex(&hasher.finalize()[..])
                    }
                };
                Ok(result)
            }
        }
        #[serde(rename_all = "lowercase")]
        enum SupportedSHA2Size {
            SHA224,
            SHA256,
            SHA384,
            SHA512,
            SHA512_224,
            SHA512_256,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SupportedSHA2Size {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 6",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "sha224" => _serde::__private::Ok(__Field::__field0),
                                "sha256" => _serde::__private::Ok(__Field::__field1),
                                "sha384" => _serde::__private::Ok(__Field::__field2),
                                "sha512" => _serde::__private::Ok(__Field::__field3),
                                "sha512_224" => _serde::__private::Ok(__Field::__field4),
                                "sha512_256" => _serde::__private::Ok(__Field::__field5),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"sha224" => _serde::__private::Ok(__Field::__field0),
                                b"sha256" => _serde::__private::Ok(__Field::__field1),
                                b"sha384" => _serde::__private::Ok(__Field::__field2),
                                b"sha512" => _serde::__private::Ok(__Field::__field3),
                                b"sha512_224" => _serde::__private::Ok(__Field::__field4),
                                b"sha512_256" => _serde::__private::Ok(__Field::__field5),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SupportedSHA2Size>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SupportedSHA2Size;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum SupportedSHA2Size",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedSHA2Size::SHA224)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedSHA2Size::SHA256)
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedSHA2Size::SHA384)
                                }
                                (__Field::__field3, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedSHA2Size::SHA512)
                                }
                                (__Field::__field4, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedSHA2Size::SHA512_224)
                                }
                                (__Field::__field5, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedSHA2Size::SHA512_256)
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "sha224",
                        "sha256",
                        "sha384",
                        "sha512",
                        "sha512_224",
                        "sha512_256",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "SupportedSHA2Size",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<SupportedSHA2Size>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct Params {
            size: SupportedSHA2Size,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Params {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "size" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"size" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Params>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Params;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Params",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                SupportedSHA2Size,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Params with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Params { size: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                SupportedSHA2Size,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("size"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SupportedSHA2Size,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("size")?
                                }
                            };
                            _serde::__private::Ok(Params { size: __field0 })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["size"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Params",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Params>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct DeserializeMeDaddy {
            input: String,
            params: Params,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                "params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                b"params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Params,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Params> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("params"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Params>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("params")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input", "params"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// The SHA-2 (Secure Hash Algorithm 2) hash functions were designed by the NSA. SHA-2 includes significant changes from its predecessor, SHA-1. The SHA-2 family consists of hash functions with digests (hash values) that are 224, 256, 384 or 512 bits: SHA224, SHA256, SHA384, SHA512. SHA-512 operates on 64-bit words. SHA-256 operates on 32-bit words. SHA-384 is largely identical to SHA-512 but is truncated to 384 bytes. SHA-224 is largely identical to SHA-256 but is truncated to 224 bytes. SHA-512/224 and SHA-512/256 are truncated versions of SHA-512, but the initial values are generated using the method described in Federal Information Processing Standards (FIPS) PUB 180-4
        /// <br><br/>
        /// For more information go [here](https://wikipedia.org/wiki/SHA-2).
        /// <br><br/>
        ///
        /// # How to use
        /// \
        /// Send POST requests to /api/SHA2 with your data using json payload with this structure.
        /// ``` json
        /// {
        ///     "input": string,
        ///     "params": {
        ///         "size": SupportedSHA2Size
        ///     }
        /// }
        /// ```
        /// #### where
        ///     - SupportedSHA2Size is enum of "sha224", "sha256", "sha384", "sha512", "sha512_224", "sha512_256"
        /// <br/><br/>
        ///
        /// ### Server response have two possible formats
        ///
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
        /// ``` json
        /// { "Ok": `some answer` }
        /// ```
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
        /// ``` json
        /// { "Err": `error message` }
        /// ```
        /// # Examples
        /// ## №1
        /// ``` http
        /// POST /api/SHA2
        ///
        /// {
        ///     "input": "hello",
        ///     "params": {
        ///         "size": "sha512"
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {
        ///   "Ok": 9b71d224bd62f3785d96d46ad3ea3d73319bfbc289caadae2dff72519673ca72323c3d99ba5c11d7c7acc6e14b8c5dac4663475c2e5c3adef46f73bcdec043"
        /// }
        /// ```
        /// ## №2
        /// ``` http
        /// POST /api/SHA2
        ///
        /// {
        ///     "input": "hello 123 world",
        ///     "params": {
        ///         "size": "sha224"
        ///     }
        /// }
        /// ```
        /// ```http
        /// {
        ///   "Ok": "1d5d7d218ccaef8b16a442970f8c56a31394126c053ef2cd8ed7f3"
        /// }
        /// ```
        /// ## №3
        /// ``` http
        /// POST /api/SHA2
        ///
        /// {
        ///     "input": "missing params"
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 400 Bad Request
        /// {
        ///   "Err": "Missing field `params`"
        /// }
        /// ```
        pub struct SHA2;
        const NAME: &str = "SHA2";
        const DESCRIPTION_EN: &str = "The SHA-2 (Secure Hash Algorithm 2) hash functions were designed by the NSA. SHA-2 includes significant changes from its predecessor, SHA-1. The SHA-2 family consists of hash functions with digests (hash values) that are 224, 256, 384 or 512 bits: SHA224, SHA256, SHA384, SHA512. SHA-512 operates on 64-bit words. SHA-256 operates on 32-bit words. SHA-384 is largely identical to SHA-512 but is truncated to 384 bytes. SHA-224 is largely identical to SHA-256 but is truncated to 224 bytes. SHA-512/224 and SHA-512/256 are truncated versions of SHA-512, but the initial values are generated using the method described in Federal Information Processing Standards (FIPS) PUB 180-4";
        const DESCRIPTION_RU: &str = "Хэш-функции SHA-2 (Secure Hash Algorithm 2) были разработаны АНБ. SHA-2 включает в себя существенные отличия от своего предшественника SHA-1. Семейство SHA-2 состоит из хеш-функций с дайджестами (хеш-значениями) размером 224, 256, 384 или 512 бит: SHA224, SHA256, SHA384, SHA512. SHA-512 работает с 64-битными словами. SHA-256 работает с 32-битными словами. SHA-384 во многом идентичен SHA-512, но усечен до 384 байт. SHA-224 во многом идентичен SHA-256, но усечен до 224 байт. SHA-512/224 и SHA-512/256 являются усеченными версиями SHA-512, но начальные значения генерируются с использованием метода, описанного в Федеральных стандартах обработки информации (FIPS) PUB 180-4.";
        const INFO_URL: Option<&str> = Some("https://wikipedia.org/wiki/SHA-2");
        pub struct Sha2Info {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Sha2Info {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "Sha2Info",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl Sha2Info {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub mod sha3_mod {
        use crate::{
            create_info_struct, create_me_daddy, create_tauri_wrapper, run_operations,
            utils::to_hex, Operation, DOCS_URL,
        };
        use anyhow::Result;
        use serde::{Deserialize, Serialize};
        use sha3::{Digest, Sha3_224, Sha3_256, Sha3_384, Sha3_512};
        pub fn sha3(request: &str) -> Result<String, String> {
            run_operations(SHA3, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__sha3;
        impl Operation<'_, DeserializeMeDaddy> for SHA3 {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let (input, size) = (request.input, request.params.size);
                let result = match size {
                    SupportedSHA3Size::SHA224 => {
                        let mut hasher = Sha3_224::new();
                        hasher.update(input);
                        to_hex(&hasher.finalize()[..])
                    }
                    SupportedSHA3Size::SHA256 => {
                        let mut hasher = Sha3_256::new();
                        hasher.update(input);
                        to_hex(&hasher.finalize()[..])
                    }
                    SupportedSHA3Size::SHA384 => {
                        let mut hasher = Sha3_384::new();
                        hasher.update(input);
                        to_hex(&hasher.finalize()[..])
                    }
                    SupportedSHA3Size::SHA512 => {
                        let mut hasher = Sha3_512::new();
                        hasher.update(input);
                        to_hex(&hasher.finalize()[..])
                    }
                };
                Ok(result)
            }
        }
        #[serde(rename_all = "lowercase")]
        enum SupportedSHA3Size {
            SHA224,
            SHA256,
            SHA384,
            SHA512,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SupportedSHA3Size {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 4",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "sha224" => _serde::__private::Ok(__Field::__field0),
                                "sha256" => _serde::__private::Ok(__Field::__field1),
                                "sha384" => _serde::__private::Ok(__Field::__field2),
                                "sha512" => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"sha224" => _serde::__private::Ok(__Field::__field0),
                                b"sha256" => _serde::__private::Ok(__Field::__field1),
                                b"sha384" => _serde::__private::Ok(__Field::__field2),
                                b"sha512" => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SupportedSHA3Size>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SupportedSHA3Size;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum SupportedSHA3Size",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedSHA3Size::SHA224)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedSHA3Size::SHA256)
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedSHA3Size::SHA384)
                                }
                                (__Field::__field3, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(SupportedSHA3Size::SHA512)
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "sha224",
                        "sha256",
                        "sha384",
                        "sha512",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "SupportedSHA3Size",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<SupportedSHA3Size>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct Params {
            size: SupportedSHA3Size,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Params {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "size" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"size" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Params>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Params;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Params",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                SupportedSHA3Size,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Params with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Params { size: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                SupportedSHA3Size,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("size"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SupportedSHA3Size,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("size")?
                                }
                            };
                            _serde::__private::Ok(Params { size: __field0 })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["size"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Params",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Params>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct DeserializeMeDaddy {
            input: String,
            params: Params,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                "params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                b"params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Params,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Params> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("params"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Params>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("params")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input", "params"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// The SHA-3 (Secure Hash Algorithm 3) hash functions were released by NIST on August 5, 2015. Although part of the same series of standards, SHA-3 is internally quite different from the MD5-like structure of SHA-1 and SHA-2. SHA-3 is a subset of the broader cryptographic primitive family Keccak designed by Guido Bertoni, Joan Daemen, Michaël Peeters, and Gilles Van Assche, building upon RadioGatún.
        /// <br><br/>
        /// For more information go [here](https://wikipedia.org/wiki/SHA-3).
        /// <br><br/>
        ///
        /// # How to use
        /// \
        /// Send POST requests to /api/SHA3 with your data using json payload with this structure.
        /// ``` json
        /// {
        ///     "input": string,
        ///     "params": {
        ///         "size": SupportedSHA2Size
        ///     }
        /// }
        /// ```
        /// #### where
        ///     - SupportedSHA2Size is enum of "sha224", "sha256", "sha384", "sha512", "sha512_224", "sha512_256"
        /// <br/><br/>
        ///
        /// ### Server response have two possible formats
        ///
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
        /// ``` json
        /// { "Ok": `some answer` }
        /// ```
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
        /// ``` json
        /// { "Err": `error message` }
        /// ```
        /// # Examples
        /// ## №1
        /// ``` http
        /// POST /api/SHA3
        ///
        /// {
        ///     "input": "hello",
        ///     "params": {
        ///         "size": "sha224"
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {
        ///   "Ok": b87f88c7272fff1748e58b87e9141a42cdbedc29a78cb0d4a5cd81"
        /// }
        /// ```
        /// ## №2
        /// ``` http
        /// POST /api/SHA3
        ///
        /// {
        ///     "input": "hello 123 world",
        ///     "params": {
        ///         "size": "sha384"
        ///     }
        /// }
        /// ```
        /// ```http
        /// {
        ///   "Ok": "061c227e47b9eb83b165c6f86de608287fb5e1639af52ed1ccf371da91561925e8d5999f5c8f5a921c7e593325c"
        /// }
        /// ```
        /// ## №3
        /// ``` http
        /// POST /api/SHA3
        ///
        /// {
        ///     "input": "missing params"
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 400 Bad Request
        /// {
        ///   "Err": "Missing field `params`"
        /// }
        /// ```
        pub struct SHA3;
        const NAME: &str = "SHA3";
        const DESCRIPTION_EN: &str = "The SHA-3 (Secure Hash Algorithm 3) hash functions were released by NIST on August 5, 2015. Although part of the same series of standards, SHA-3 is internally quite different from the MD5-like structure of SHA-1 and SHA-2. SHA-3 is a subset of the broader cryptographic primitive family Keccak designed by Guido Bertoni, Joan Daemen, Michaël Peeters, and Gilles Van Assche, building upon RadioGatún.";
        const DESCRIPTION_RU: &str = "Хэш-функции SHA-3 (Secure Hash Algorithm 3) были выпущены NIST 5 августа 2015 года. Хотя SHA-3 является частью той же серии стандартов, внутренне он сильно отличается от MD5-подобной структуры SHA-1 и SHA. -2. SHA-3 — это подмножество более широкого семейства криптографических примитивов Keccak, разработанного Гвидо Бертони, Джоан Демен, Микаэлем Петерсом и Жилем Ван Аше на основе RadioGatún.";
        const INFO_URL: Option<&str> = Some("https://wikipedia.org/wiki/SHA-3");
        pub struct Sha3Info {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Sha3Info {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "Sha3Info",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl Sha3Info {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub mod to_base64_mod {
        use anyhow::Result;
        use serde::{Deserialize, Serialize};
        use crate::{
            create_info_struct, create_me_daddy, create_tauri_wrapper,
            libs::base64::to_base64 as to_base64_lib, run_operations, Operation, DOCS_URL,
        };
        pub fn to_base64(request: &str) -> Result<String, String> {
            run_operations(ToBase64, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__to_base64;
        impl Operation<'_, DeserializeMeDaddy> for ToBase64 {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let (input, alphabet) = (request.input, request.params.alphabet);
                Ok(to_base64_lib(input.as_bytes(), alphabet)?)
            }
        }
        pub struct Params {
            alphabet: Option<String>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Params {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "alphabet" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"alphabet" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Params>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Params;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Params",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Params with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Params { alphabet: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "alphabet",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("alphabet")?
                                }
                            };
                            _serde::__private::Ok(Params { alphabet: __field0 })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["alphabet"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Params",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Params>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct DeserializeMeDaddy {
            input: String,
            params: Params,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                "params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                b"params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Params,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Params> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("params"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Params>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("params")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input", "params"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// Base64 is a notation for encoding arbitrary byte data using a restricted set of symbols that can be conveniently used by humans and processed by computers.<br><br>This operation decodes raw data into an ASCII Base64 string.
        /// <br><br/>
        /// For more information go [here](https://wikipedia.org/wiki/Base64).
        /// <br><br/>
        ///
        /// # How to use
        /// \
        /// Send POST requests to /api/ToBase64 with your data using json payload with this structure.
        /// ``` json
        /// {
        ///     "input": string,
        ///     "params": {
        ///         "alphabet": Option<string>,
        ///     }
        /// }
        /// ```
        /// #### where
        ///     - Option<string> is type that can be string or null.
        /// <br/><br/>
        ///
        /// ### Server response have two possible formats
        ///
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
        /// ``` json
        /// { "Ok": `some answer` }
        /// ```
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
        /// ``` json
        /// { "Err": `error message` }
        /// ```
        /// # Examples
        /// ## №1
        /// ``` http
        /// POST /api/ToBase64
        ///
        /// {
        ///     "input": "hello",
        ///     "params": {
        ///         "alphabet": "A-Za-z0-9+/=",
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {
        ///   "Ok": aGVsbG8="
        /// }
        /// ```
        /// ## №2
        /// ``` http
        /// POST /api/ToBase64
        ///
        /// {
        ///     "input": "hello",
        ///     "params": {
        ///         "alphabet": " -_",
        ///     }
        /// }
        /// ```
        /// ```http
        /// {
        ///   "Ok": ":&5L;&\"
        /// }
        /// ```
        /// ## №3
        /// ``` http
        /// POST /api/ToBase64
        ///
        /// {
        ///     "params": {
        ///         "alphabet": "t/RPURZbnkPVD="
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 400 Bad Request
        /// {
        ///   "Err": "Missing field `input`"
        /// }
        /// ```
        pub struct ToBase64;
        const NAME: &str = "ToBase64";
        const DESCRIPTION_EN: &str = "Base64 is a notation for encoding arbitrary byte data using a restricted set of symbols that can be conveniently used by humans and processed by computers.<br><br>This operation decodes raw data into an ASCII Base64 string.";
        const DESCRIPTION_RU: &str = "Base64 — это нотация для кодирования произвольных байтовых данных с использованием ограниченного набора символов, которые могут удобно использоваться людьми и обрабатываться компьютерами.<br><br>Эта операция декодирует необработанные данные в строку ASCII Base64.";
        const INFO_URL: Option<&str> = Some("https://wikipedia.org/wiki/Base64");
        pub struct ToBase64Info {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ToBase64Info {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "ToBase64Info",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl ToBase64Info {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub mod to_base_mod {
        use anyhow::Result;
        use num::{BigInt, Num};
        use serde::{Deserialize, Serialize};
        use serde_valid::Validate;
        use crate::{
            create_info_struct, create_me_daddy, create_tauri_wrapper, run_operations,
            Operation, DOCS_URL,
        };
        pub fn to_base(request: &str) -> Result<String, String> {
            run_operations(ToBase, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__to_base;
        impl Operation<'_, DeserializeMeDaddy> for ToBase {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let (input, radix) = (request.input, request.params.radix);
                #[allow(non_snake_case)]
                let big_D_number = BigInt::from_str_radix(&input, 10)
                    .map_err(|_| anyhow::Error::msg("Invalid symbols found in string"))?;
                Ok(big_D_number.to_str_radix(radix))
            }
        }
        struct Params {
            #[validate(maximum = 36)]
            #[validate(minimum = 2)]
            radix: u32,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Params {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "radix" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"radix" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Params>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Params;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Params",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                u32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Params with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Params { radix: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<u32> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("radix"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("radix")?
                                }
                            };
                            _serde::__private::Ok(Params { radix: __field0 })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["radix"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Params",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Params>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl ::serde_valid::Validate for Params {
            fn validate(
                &self,
            ) -> std::result::Result<(), ::serde_valid::validation::Errors> {
                let mut __rule_vec_errors = ::serde_valid::validation::VecErrors::new();
                let mut __property_vec_errors_map = ::serde_valid::validation::PropertyVecErrorsMap::new();
                let radix = &self.radix;
                if let Err(__composited_error_params)
                    = ::serde_valid::validation::ValidateCompositedMaximum::validate_composited_maximum(
                        radix,
                        36,
                    ) {
                    use ::serde_valid::validation::{IntoError, ToDefaultMessage};
                    __property_vec_errors_map
                        .entry("radix".to_string())
                        .or_default()
                        .push(
                            __composited_error_params
                                .into_error_by(::serde_valid::validation::CustomMessage {
                                    message_fn: ::serde_valid::validation::ToDefaultMessage::to_default_message,
                                }),
                        );
                }
                if let Err(__composited_error_params)
                    = ::serde_valid::validation::ValidateCompositedMinimum::validate_composited_minimum(
                        radix,
                        2,
                    ) {
                    use ::serde_valid::validation::{IntoError, ToDefaultMessage};
                    __property_vec_errors_map
                        .entry("radix".to_string())
                        .or_default()
                        .push(
                            __composited_error_params
                                .into_error_by(::serde_valid::validation::CustomMessage {
                                    message_fn: ::serde_valid::validation::ToDefaultMessage::to_default_message,
                                }),
                        );
                }
                if __rule_vec_errors.is_empty() && __property_vec_errors_map.is_empty() {
                    Ok(())
                } else {
                    Err(
                        ::serde_valid::validation::Errors::Object(
                            ::serde_valid::validation::ObjectErrors::new(
                                __rule_vec_errors,
                                __property_vec_errors_map
                                    .into_iter()
                                    .map(|(field, errors)| {
                                        let mut __field_items_errors = ::alloc::vec::Vec::new();
                                        let mut __field_properties_errors = None;
                                        let mut __field_errors: ::serde_valid::validation::VecErrors = errors
                                            .into_iter()
                                            .filter_map(|error| match error {
                                                ::serde_valid::validation::Error::Items(__array_errors) => {
                                                    __field_items_errors.push(__array_errors);
                                                    None
                                                }
                                                ::serde_valid::validation::Error::Properties(
                                                    __object_errors,
                                                ) => {
                                                    __field_properties_errors = Some(__object_errors);
                                                    None
                                                }
                                                _ => Some(error),
                                            })
                                            .collect();
                                        if let Some(__object_errors) = __field_properties_errors {
                                            __field_errors.extend(__object_errors.errors);
                                            (
                                                field,
                                                ::serde_valid::validation::Errors::Object(
                                                    ::serde_valid::validation::ObjectErrors::new(
                                                        __field_errors,
                                                        __object_errors.properties,
                                                    ),
                                                ),
                                            )
                                        } else if !__field_items_errors.is_empty() {
                                            let __array_errors = __field_items_errors
                                                .into_iter()
                                                .reduce(|a, b| a.merge(b))
                                                .unwrap();
                                            __field_errors.extend(__array_errors.errors);
                                            (
                                                field,
                                                ::serde_valid::validation::Errors::Array(
                                                    ::serde_valid::validation::ArrayErrors::new(
                                                        __field_errors,
                                                        __array_errors.items,
                                                    ),
                                                ),
                                            )
                                        } else {
                                            (
                                                field,
                                                ::serde_valid::validation::Errors::NewType(__field_errors),
                                            )
                                        }
                                    })
                                    .collect(),
                            ),
                        ),
                    )
                }
            }
        }
        struct DeserializeMeDaddy {
            input: String,
            params: Params,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                "params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                b"params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Params,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Params> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("params"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Params>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("params")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input", "params"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// Converts a number from decimal to a given numerical base.
        /// <br><br/>
        /// For more information go [here](https://wikipedia.org/wiki/Radix).
        /// <br><br/>
        ///
        /// # How to use
        /// \
        /// Send POST requests to /api/ToBase with your data using json payload with this structure.
        /// ``` json
        /// {
        ///     "input": string,
        ///     "params": {
        ///         "radix": u36,
        ///     }
        /// }
        /// ```
        /// #### where
        ///     - u36 is digit between 2 and 36 inclusive
        /// <br/><br/>
        ///
        /// ### Server response have two possible formats
        ///
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
        /// ``` json
        /// { "Ok": `some answer` }
        /// ```
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
        /// ``` json
        /// { "Err": `error message` }
        /// ```
        /// # Examples
        /// ## №1
        /// ``` http
        /// POST /api/ToBase
        ///
        /// {
        ///     "input": "123",
        ///     "params": {
        ///         "radix": 15
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {
        ///   "Ok": "83"
        /// }
        /// ```
        /// ## №2
        /// ``` http
        /// POST /api/ToBase
        ///
        /// {
        ///     "input": "3735928559",
        ///     "params": {
        ///         "radix": 16
        ///     }
        /// }
        /// ``
        /// ```
        /// ```http
        /// {
        ///   "Ok": "deadbeef"
        /// }
        /// ```
        /// ## №3
        /// ``` http
        /// POST /api/ToBase
        /// content_type: application/json; charset=utf-8
        ///
        /// {
        ///     "input": "69",
        ///     "params": {
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 400 Bad Request
        /// {
        ///   "Err": "Missing field `radix`."
        /// }
        /// ```
        pub struct ToBase;
        const NAME: &str = "ToBase";
        const DESCRIPTION_EN: &str = "Converts a number from decimal to a given numerical base.";
        const DESCRIPTION_RU: &str = "Преобразует число из десятичного в заданное числовое основание.";
        const INFO_URL: Option<&str> = Some("https://wikipedia.org/wiki/Radix");
        pub struct ToBaseInfo {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ToBaseInfo {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "ToBaseInfo",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl ToBaseInfo {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub mod vigenere_cipher_decode_mod {
        use anyhow::Result;
        use serde::{Deserialize, Serialize};
        use crate::{
            create_info_struct, create_me_daddy, create_tauri_wrapper,
            libs::vigenere_trait::VigenereCipher, run_operations,
            utils::{sub, SupportedLanguages},
            Operation, DOCS_URL,
        };
        pub fn vigenere_cipher_decode(request: &str) -> Result<String, String> {
            run_operations(VigenereCipherDecode, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__vigenere_cipher_decode;
        impl VigenereCipher for VigenereCipherDecode {}
        impl Operation<'_, DeserializeMeDaddy> for VigenereCipherDecode {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let (input, Params { lang, key }) = (request.input, request.params);
                <Self as VigenereCipher>::cipher(lang, &key, &input, sub)
            }
        }
        struct Params {
            lang: SupportedLanguages,
            key: String,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Params {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "lang" => _serde::__private::Ok(__Field::__field0),
                                "key" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"lang" => _serde::__private::Ok(__Field::__field0),
                                b"key" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Params>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Params;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Params",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                SupportedLanguages,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Params with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Params with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Params {
                                lang: __field0,
                                key: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                SupportedLanguages,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("lang"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SupportedLanguages,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("key"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("lang")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("key")?
                                }
                            };
                            _serde::__private::Ok(Params {
                                lang: __field0,
                                key: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["lang", "key"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Params",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Params>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct DeserializeMeDaddy {
            input: String,
            params: Params,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                "params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                b"params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Params,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Params> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("params"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Params>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("params")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input", "params"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// The Vigenere cipher is a method of encrypting alphabetic text by using a series of different Caesar common based on the letters of a keyword. It is a simple form of polyalphabetic substitution.
        /// <br><br/>
        /// For more information go [here](https://wikipedia.org/wiki/Vigenère_cipher).
        /// <br><br/>
        ///
        /// # How to use
        /// \
        /// Send POST requests to /api/VigenereCipherDecode with your data using json payload with this structure.
        /// ``` json
        /// {
        ///     "input": string,
        ///     "params": {
        ///         "lang": SupportedLanguages,
        ///         "key": String
        ///     }
        /// }
        /// ```
        /// #### where
        ///     - SupportedLanguages is enum of "en", "ru", "ru_with_yo".
        /// <br/><br/>
        ///
        /// ### Server response have two possible formats
        ///
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
        /// ``` json
        /// { "Ok": `some answer` }
        /// ```
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
        /// ``` json
        /// { "Err": `error message` }
        /// ```
        /// # Examples
        /// ## №1
        /// ``` http
        /// POST /api/VigenereCipherDecode
        ///
        /// {
        ///     "input": "Rijvs, Uyvjn!",
        ///     "params": {
        ///         "lang": "en",
        ///         "key": "key"
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {
        ///   "Ok": "Hello, World!"
        /// }
        /// ```
        /// ## №2
        /// ``` http
        /// POST /api/VigenereCipherDecode
        ///
        /// {
        ///     "input": "Ееклыз, Осж!",
        ///     "params": {
        ///         "lang": "ru",
        ///         "key": "ключ"
        ///     }
        /// }
        /// ```
        /// ```http
        /// {
        ///   "Ok": "Привет, Мир!"
        /// }
        /// ```
        /// ## №3
        /// ``` http
        /// POST /api/VigenereCipherDecode
        ///
        /// {
        ///     "input": "hrbtr lntrunmp",
        ///     "params": {
        ///         "lang": "else",
        ///         "key": "lang"
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 400 Bad Request
        /// {
        ///   "Err": "Unknown variant `else`, expected one of `En`, `Ru`, `RuAlpWithYo`."
        /// }
        /// ```
        pub struct VigenereCipherDecode;
        const NAME: &str = "VigenereDecode";
        const DESCRIPTION_EN: &str = "The Vigenere cipher is a method of encrypting alphabetic text by using a series of different Caesar common based on the letters of a keyword. It is a simple form of polyalphabetic substitution.";
        const DESCRIPTION_RU: &str = "Шифр Виженера — это метод шифрования алфавитного текста с использованием ряда различных общих символов Цезаря, основанных на буквах ключевого слова. Это простая форма полиалфавитной замены.";
        const INFO_URL: Option<&str> = Some(
            "https://wikipedia.org/wiki/Vigenère_cipher",
        );
        pub struct VigenereCipherDecodeInfo {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for VigenereCipherDecodeInfo {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "VigenereCipherDecodeInfo",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl VigenereCipherDecodeInfo {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub mod vigenere_cipher_encode_mod {
        use anyhow::Result;
        use serde::{Deserialize, Serialize};
        use crate::{
            create_info_struct, create_me_daddy, create_tauri_wrapper,
            libs::vigenere_trait::VigenereCipher, run_operations,
            utils::{add, SupportedLanguages},
            Operation, DOCS_URL,
        };
        pub fn vigenere_cipher_encode(request: &str) -> Result<String, String> {
            run_operations(VigenereCipherEncode, request).map_err(|e| e.to_string())
        }
        #[allow(unused_imports)]
        pub use __cmd__vigenere_cipher_encode;
        impl VigenereCipher for VigenereCipherEncode {}
        impl Operation<'_, DeserializeMeDaddy> for VigenereCipherEncode {
            fn do_black_magic(&self, request: &str) -> Result<String> {
                let request = self.validate(request)?;
                let (input, Params { lang, key }) = (request.input, request.params);
                <Self as VigenereCipher>::cipher(lang, &key, &input, add)
            }
        }
        struct Params {
            lang: SupportedLanguages,
            key: String,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Params {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "lang" => _serde::__private::Ok(__Field::__field0),
                                "key" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"lang" => _serde::__private::Ok(__Field::__field0),
                                b"key" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Params>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Params;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Params",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                SupportedLanguages,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Params with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Params with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Params {
                                lang: __field0,
                                key: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                SupportedLanguages,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("lang"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SupportedLanguages,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("key"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("lang")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("key")?
                                }
                            };
                            _serde::__private::Ok(Params {
                                lang: __field0,
                                key: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["lang", "key"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Params",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Params>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct DeserializeMeDaddy {
            input: String,
            params: Params,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeserializeMeDaddy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "input" => _serde::__private::Ok(__Field::__field0),
                                "params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"input" => _serde::__private::Ok(__Field::__field0),
                                b"params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DeserializeMeDaddy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeserializeMeDaddy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeserializeMeDaddy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Params,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DeserializeMeDaddy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Params> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("params"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Params>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("params")?
                                }
                            };
                            _serde::__private::Ok(DeserializeMeDaddy {
                                input: __field0,
                                params: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["input", "params"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeserializeMeDaddy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DeserializeMeDaddy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// The Vigenere cipher is a method of encrypting alphabetic text by using a series of different Caesar common based on the letters of a keyword. It is a simple form of polyalphabetic substitution.
        /// <br><br/>
        /// For more information go [here](https://wikipedia.org/wiki/Vigenère_cipher).
        /// <br><br/>
        ///
        /// # How to use
        /// \
        /// Send POST requests to /api/VigenereCipherEncode with your data using json payload with this structure.
        /// ``` json
        /// {
        ///     "input": string,
        ///     "params": {
        ///         "lang": SupportedLanguages,
        ///         "key": String
        ///     }
        /// }
        /// ```
        /// #### where
        ///     - SupportedLanguages is enum of "en", "ru", "ru_with_yo".
        /// <br/><br/>
        ///
        /// ### Server response have two possible formats
        ///
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
        /// ``` json
        /// { "Ok": `some answer` }
        /// ```
        /// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
        /// ``` json
        /// { "Err": `error message` }
        /// ```
        /// # Examples
        /// ## №1
        /// ``` http
        /// POST /api/VigenereCipherEncode
        ///
        /// {
        ///     "input": "Hello, World!",
        ///     "params": {
        ///         "lang": "en",
        ///         "key": "key"
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 200 Ok
        /// {
        ///   "Ok": "Rijvs, Uyvjn!"
        /// }
        /// ```
        /// ## №2
        /// ``` http
        /// POST /api/VigenereCipherEncode
        ///
        /// {
        ///     "input": "Привет, Мир!",
        ///     "params": {
        ///         "lang": "ru",
        ///         "key": "ключ"
        ///     }
        /// }
        /// ```
        /// ```http
        /// {
        ///   "Ok": "Ееклыз, Осж!"
        /// }
        /// ```
        /// ## №3
        /// ``` http
        /// POST /api/VigenereCipherEncode
        ///
        /// {
        ///     "input": "wrong language",
        ///     "params": {
        ///         "lang": "else",
        ///         "key": "lang"
        ///     }
        /// }
        /// ```
        /// ```http
        /// HTTP/1.1 400 Bad Request
        /// {
        ///   "Err": "Unknown variant `else`, expected one of `En`, `Ru`, `RuAlpWithYo`."
        /// }
        /// ```
        pub struct VigenereCipherEncode;
        const NAME: &str = "VigenereEncode";
        const DESCRIPTION_EN: &str = "The Vigenere cipher is a method of encrypting alphabetic text by using a series of different Caesar common based on the letters of a keyword. It is a simple form of polyalphabetic substitution.";
        const DESCRIPTION_RU: &str = "Шифр Виженера — это метод шифрования алфавитного текста с использованием ряда различных общих символов Цезаря, основанных на буквах ключевого слова. Это простая форма полиалфавитной замены.";
        const INFO_URL: Option<&str> = Some(
            "https://wikipedia.org/wiki/Vigenère_cipher",
        );
        pub struct VigenereCipherEncodeInfo {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for VigenereCipherEncodeInfo {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "VigenereCipherEncodeInfo",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documentation",
                        &self.documentation,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_en",
                        &self.description_en,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description_ru",
                        &self.description_ru,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "info_url",
                        &self.info_url,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl VigenereCipherEncodeInfo {
            pub fn info() -> String {
                let structure = Self {
                    name: NAME,
                    documentation: DOCS_URL,
                    description_en: DESCRIPTION_EN,
                    description_ru: DESCRIPTION_RU,
                    info_url: INFO_URL,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    }
    pub use a1z26_cipher_decode_mod::*;
    pub use a1z26_cipher_encode_mod::*;
    pub use add_line_numbers_mod::*;
    pub use add_mod::*;
    pub use adler32_checksum_mod::*;
    pub use affine_cipher_decode_mod::*;
    pub use affine_cipher_encode_mod::*;
    pub use analyse_hash_mod::*;
    pub use and_mod::*;
    pub use argon2_compare_mod::*;
    pub use argon2_mod::*;
    pub use atbash_cipher_mod::*;
    pub use bacon_cipher_decode_mod::*;
    pub use bacon_cipher_encode_mod::*;
    pub use bcrypt_compare_mod::*;
    pub use bcrypt_mod::*;
    pub use bcrypt_parse_mod::*;
    pub use bifid_cipher_encode_mod::*;
    pub use blake2b_mod::*;
    pub use blake2s_mod::*;
    pub use filter_mod::*;
    pub use from_base64_mod::*;
    pub use from_base_mod::*;
    pub use hmac_mod::*;
    pub use md2_mod::*;
    pub use md4_mod::*;
    pub use md5_mod::*;
    pub use reverse_mod::*;
    pub use rsa_decrypt_mod::*;
    pub use rsa_encrypt_mod::*;
    pub use scrypt_mod::*;
    pub use sha1_mod::*;
    pub use sha2_mod::*;
    pub use sha3_mod::*;
    pub use to_base64_mod::*;
    pub use to_base_mod::*;
    pub use vigenere_cipher_decode_mod::*;
    pub use vigenere_cipher_encode_mod::*;
    pub use a1z26_cipher_decode_mod::Delimiters;
    pub use analyse_hash_mod::SerializeMeDaddy as AnalyseHashSerializeMeDaddy;
    pub use bcrypt_parse_mod::HashParts as BcryptParseHashParts;
}
mod traits {
    use std::collections::HashSet;
    pub trait CharTrait {
        fn to_lower_case(&self) -> Self;
        fn to_upper_case(&self) -> Self;
    }
    impl CharTrait for char {
        fn to_lower_case(&self) -> char {
            match self {
                'A'..='Z' => self.to_ascii_lowercase(),
                'А'..='Я' | 'Ё' => self.to_uppercase().next().unwrap(),
                _ => *self,
            }
        }
        fn to_upper_case(&self) -> char {
            match self {
                'a'..='z' => self.to_ascii_uppercase(),
                'а'..='я' | 'ё' => self.to_uppercase().next().unwrap(),
                _ => *self,
            }
        }
    }
    pub trait StringTrait {
        fn replace_by_alphabet(&self, alphabet: &str) -> String;
        fn regex_replace_all(
            &self,
            regex: &str,
            replacement: &str,
        ) -> Result<String, String>;
        fn regex_replace(
            &self,
            regex: &str,
            replacement: &str,
        ) -> Result<String, String>;
        fn capitalize(&self) -> String;
    }
    impl StringTrait for String {
        fn replace_by_alphabet(&self, alphabet: &str) -> String {
            let alphabet: HashSet<char> = HashSet::from_iter(alphabet.chars());
            self.chars().filter(|c| alphabet.contains(c)).collect::<String>()
        }
        fn regex_replace_all(
            &self,
            regex_str: &str,
            replacement: &str,
        ) -> Result<String, String> {
            let re = regex::Regex::new(regex_str)
                .map_err(|_| String::from("wrong regex"))?;
            let output: String = re.replace_all(regex_str, replacement).to_string();
            Ok(output)
        }
        fn regex_replace(
            &self,
            regex_str: &str,
            replacement: &str,
        ) -> Result<String, String> {
            let re = regex::Regex::new(regex_str)
                .map_err(|_| String::from("wrong regex"))?;
            let output: String = re.replace(regex_str, replacement).to_string();
            Ok(output)
        }
        fn capitalize(&self) -> String {
            let mut c = self.chars();
            match c.next() {
                None => String::new(),
                Some(f) => {
                    let res = ::alloc::fmt::format(
                        format_args!("{0}{1}", f.to_upper_case(), c.as_str()),
                    );
                    res
                }
            }
        }
    }
    pub trait IntegerTrait {
        fn gcd(&self, other: &Self) -> Self;
    }
    impl IntegerTrait for i16 {
        fn gcd(&self, other: &Self) -> i16 {
            if *self == 0 {
                return *other;
            }
            if *other == 0 {
                return *self;
            }
            let mut a = *self;
            let mut b = *other;
            while b != 0 {
                let temp = b;
                b = a % b;
                a = temp;
            }
            a
        }
    }
}
mod utils {
    use crate::{libs::base64::from_base64, map, regex_check};
    use anyhow::{anyhow, bail, Result};
    use num::{Integer, ToPrimitive};
    use serde::{Deserialize, Serialize};
    use std::fmt::{Debug, LowerHex};
    #[serde(rename_all = "lowercase")]
    pub enum SupportedLanguages {
        EN,
        RU,
        #[allow(non_camel_case_types)]
        RU_WITH_YO,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for SupportedLanguages {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 3",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "en" => _serde::__private::Ok(__Field::__field0),
                            "ru" => _serde::__private::Ok(__Field::__field1),
                            "ru_with_yo" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"en" => _serde::__private::Ok(__Field::__field0),
                            b"ru" => _serde::__private::Ok(__Field::__field1),
                            b"ru_with_yo" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<SupportedLanguages>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = SupportedLanguages;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum SupportedLanguages",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(SupportedLanguages::EN)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(SupportedLanguages::RU)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(SupportedLanguages::RU_WITH_YO)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["en", "ru", "ru_with_yo"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "SupportedLanguages",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<SupportedLanguages>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(clippy::upper_case_acronyms)]
    #[serde(rename_all = "lowercase")]
    pub enum SupportedFormats {
        BINARY,
        UTF8,
        HEX,
        BASE64,
        LATIN1,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for SupportedFormats {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    SupportedFormats::BINARY => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SupportedFormats",
                            0u32,
                            "binary",
                        )
                    }
                    SupportedFormats::UTF8 => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SupportedFormats",
                            1u32,
                            "utf8",
                        )
                    }
                    SupportedFormats::HEX => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SupportedFormats",
                            2u32,
                            "hex",
                        )
                    }
                    SupportedFormats::BASE64 => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SupportedFormats",
                            3u32,
                            "base64",
                        )
                    }
                    SupportedFormats::LATIN1 => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SupportedFormats",
                            4u32,
                            "latin1",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for SupportedFormats {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 5",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "binary" => _serde::__private::Ok(__Field::__field0),
                            "utf8" => _serde::__private::Ok(__Field::__field1),
                            "hex" => _serde::__private::Ok(__Field::__field2),
                            "base64" => _serde::__private::Ok(__Field::__field3),
                            "latin1" => _serde::__private::Ok(__Field::__field4),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"binary" => _serde::__private::Ok(__Field::__field0),
                            b"utf8" => _serde::__private::Ok(__Field::__field1),
                            b"hex" => _serde::__private::Ok(__Field::__field2),
                            b"base64" => _serde::__private::Ok(__Field::__field3),
                            b"latin1" => _serde::__private::Ok(__Field::__field4),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<SupportedFormats>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = SupportedFormats;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum SupportedFormats",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(SupportedFormats::BINARY)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(SupportedFormats::UTF8)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(SupportedFormats::HEX)
                            }
                            (__Field::__field3, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(SupportedFormats::BASE64)
                            }
                            (__Field::__field4, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(SupportedFormats::LATIN1)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "binary",
                    "utf8",
                    "hex",
                    "base64",
                    "latin1",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "SupportedFormats",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<SupportedFormats>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    #[allow(clippy::upper_case_acronyms)]
    impl ::core::fmt::Debug for SupportedFormats {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    SupportedFormats::BINARY => "BINARY",
                    SupportedFormats::UTF8 => "UTF8",
                    SupportedFormats::HEX => "HEX",
                    SupportedFormats::BASE64 => "BASE64",
                    SupportedFormats::LATIN1 => "LATIN1",
                },
            )
        }
    }
    pub enum DataRepresentation {
        String(String),
        ByteArray(Vec<u8>),
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for DataRepresentation {}
    #[automatically_derived]
    impl ::core::cmp::Eq for DataRepresentation {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<String>;
            let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for DataRepresentation {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for DataRepresentation {
        #[inline]
        fn eq(&self, other: &DataRepresentation) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        DataRepresentation::String(__self_0),
                        DataRepresentation::String(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DataRepresentation::ByteArray(__self_0),
                        DataRepresentation::ByteArray(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DataRepresentation {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                DataRepresentation::String(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "String",
                        &__self_0,
                    )
                }
                DataRepresentation::ByteArray(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ByteArray",
                        &__self_0,
                    )
                }
            }
        }
    }
    pub enum DataRepresentationInput {
        String,
        ByteArray,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for DataRepresentationInput {}
    #[automatically_derived]
    impl ::core::cmp::Eq for DataRepresentationInput {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for DataRepresentationInput {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for DataRepresentationInput {
        #[inline]
        fn eq(&self, other: &DataRepresentationInput) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DataRepresentationInput {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    DataRepresentationInput::String => "String",
                    DataRepresentationInput::ByteArray => "ByteArray",
                },
            )
        }
    }
    #[allow(clippy::upper_case_acronyms)]
    pub enum SupportedDelimiter {
        Space,
        #[serde(rename = "Line feed")]
        LineFeed,
        CRLF,
        Comma,
        #[serde(rename = "Semi-colon")]
        SemiColon,
        Colon,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for SupportedDelimiter {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 6",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Space" => _serde::__private::Ok(__Field::__field0),
                            "Line feed" => _serde::__private::Ok(__Field::__field1),
                            "CRLF" => _serde::__private::Ok(__Field::__field2),
                            "Comma" => _serde::__private::Ok(__Field::__field3),
                            "Semi-colon" => _serde::__private::Ok(__Field::__field4),
                            "Colon" => _serde::__private::Ok(__Field::__field5),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Space" => _serde::__private::Ok(__Field::__field0),
                            b"Line feed" => _serde::__private::Ok(__Field::__field1),
                            b"CRLF" => _serde::__private::Ok(__Field::__field2),
                            b"Comma" => _serde::__private::Ok(__Field::__field3),
                            b"Semi-colon" => _serde::__private::Ok(__Field::__field4),
                            b"Colon" => _serde::__private::Ok(__Field::__field5),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<SupportedDelimiter>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = SupportedDelimiter;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum SupportedDelimiter",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(SupportedDelimiter::Space)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(SupportedDelimiter::LineFeed)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(SupportedDelimiter::CRLF)
                            }
                            (__Field::__field3, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(SupportedDelimiter::Comma)
                            }
                            (__Field::__field4, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(SupportedDelimiter::SemiColon)
                            }
                            (__Field::__field5, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(SupportedDelimiter::Colon)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "Space",
                    "Line feed",
                    "CRLF",
                    "Comma",
                    "Semi-colon",
                    "Colon",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "SupportedDelimiter",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<SupportedDelimiter>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    #[allow(clippy::upper_case_acronyms)]
    impl ::core::fmt::Debug for SupportedDelimiter {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    SupportedDelimiter::Space => "Space",
                    SupportedDelimiter::LineFeed => "LineFeed",
                    SupportedDelimiter::CRLF => "CRLF",
                    SupportedDelimiter::Comma => "Comma",
                    SupportedDelimiter::SemiColon => "SemiColon",
                    SupportedDelimiter::Colon => "Colon",
                },
            )
        }
    }
    impl std::fmt::Display for SupportedDelimiter {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            f.write_fmt(format_args!("{0:?}", self))
        }
    }
    pub const EN_ALP: (&str, &str, &str, &str, u8, &str) = (
        "abcdefghijklmnopqrstuvwxyz",
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
        "abcdefghiklmnopqrstuvwxyz",
        "ABCDEFGHIKLMNOPQRSTUVWXYZ",
        26,
        r"^[a-zA-Z]+$",
    );
    pub const RU_ALP: (&str, &str, &str, &str, u8, &str) = (
        "абвгдежзийклмнопрстуфхцчшщъыьэюя",
        "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ",
        "абвгдежзийклмнопрстуфхцчшщъыьэюя,.-=",
        "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ,.-=",
        32,
        "^[а-яА-Я]+$",
    );
    pub const RU_ALP_WITH_YO: (&str, &str, &str, &str, u8, &str) = (
        "абвгдеёжзийклмнопрстуфхцчшщъыьэюя",
        "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ",
        "абвгдеёжзийклмнопрстуфхцчшщъыьэюя,.-",
        "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ,.-",
        33,
        r"^[а-яА-ЯёЁ]+$",
    );
    pub const _NUM: (&str, &str) = ("0123456789", r"^\+?(0|[1-9]\d*)$");
    pub fn expand_alphabet_range(alphabet: &str) -> Vec<char> {
        let mut result: Vec<char> = Vec::new();
        let alphabet_length = alphabet.chars().count();
        let mut i = 0;
        while i < alphabet_length {
            let by_index = get_char_by_index(alphabet, i);
            if (i < alphabet_length - 2) && (get_char_by_index(alphabet, i + 1) == '-')
                && (by_index != '\\')
            {
                let (start, end) = (
                    ord(by_index),
                    ord(get_char_by_index(alphabet, i + 2)),
                );
                for j in start..=end {
                    result.push(chr(j));
                }
                i += 2;
            } else if (i < alphabet_length - 2) && (by_index == '\\')
                && (get_char_by_index(alphabet, i + 1) == '-')
            {
                result.push('-');
                i += 1;
            } else {
                result.push(by_index);
            }
            i += 1;
        }
        result
    }
    pub fn _str_to_array_buffer(string: &str) -> Vec<u32> {
        if string.is_empty() {
            return Vec::new();
        }
        let string_length = string.chars().count();
        let mut result: Vec<u32> = ::alloc::vec::from_elem(0, string_length);
        for (idx, elem) in result.iter_mut().enumerate() {
            *elem = ord(get_char_by_index(string, idx));
        }
        result
    }
    pub fn str_to_array_buffer_by_alphabet(string: &str, alphabet: &str) -> Vec<usize> {
        if string.is_empty() {
            return Vec::new();
        }
        let string_length = string.chars().count();
        let mut result: Vec<usize> = ::alloc::vec::from_elem(0, string_length);
        for (idx, c) in string.chars().enumerate() {
            result[idx] = get_index_by_char(alphabet, c);
        }
        result
    }
    pub fn _byte_array_to_string(byte_array: Vec<u8>) -> Result<String> {
        Ok(String::from_utf8(byte_array)?)
    }
    pub fn convert_to_byte_array(
        string: &str,
        convert_type: &SupportedFormats,
    ) -> Result<Vec<u8>> {
        match convert_type {
            SupportedFormats::BINARY => from_binary(string, None, None),
            SupportedFormats::HEX => from_hex(string, None, None),
            SupportedFormats::BASE64 => {
                match from_base64(
                    string.to_string(),
                    "",
                    DataRepresentationInput::ByteArray,
                    true,
                    false,
                ) {
                    Ok(data) => {
                        let DataRepresentation::ByteArray(data) = data else {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        ) };
                        Ok(data)
                    }
                    Err(e) => {
                        Err(
                            ::anyhow::__private::must_use({
                                use ::anyhow::__private::kind::*;
                                let error = match e {
                                    error => (&error).anyhow_kind().new(error),
                                };
                                error
                            }),
                        )
                    }
                }
            }
            SupportedFormats::UTF8 => Ok(string.as_bytes().to_vec()),
            SupportedFormats::LATIN1 => Ok(Vec::new()),
        }
    }
    pub fn from_binary(
        data: &str,
        delim: Option<&str>,
        byte_len: Option<usize>,
    ) -> Result<Vec<u8>> {
        if byte_len.unwrap_or(8) < 1 {
            return ::anyhow::__private::Err({
                let error = ::anyhow::__private::format_err(
                    format_args!("Byte length must be a positive integer"),
                );
                error
            });
        }
        let delim = char_repr(delim.unwrap_or("Space"));
        let data = data.replace(delim, " ");
        let mut output: Vec<u8> = Vec::new();
        for i in data.split_whitespace() {
            match u8::from_str_radix(i, 2) {
                Ok(data) => output.push(data),
                Err(e) => {
                    return ::anyhow::__private::Err({
                        use ::anyhow::__private::kind::*;
                        let error = match e {
                            error => (&error).anyhow_kind().new(error),
                        };
                        error
                    });
                }
            }
        }
        Ok(output)
    }
    pub fn to_hex(data: &[u8]) -> String {
        data.iter()
            .fold(
                String::new(),
                |out, x| {
                    let res = ::alloc::fmt::format(format_args!("{0}{1:02x}", out, x));
                    res
                },
            )
    }
    pub fn from_hex(
        data: &str,
        delim: Option<&str>,
        byte_len: Option<usize>,
    ) -> Result<Vec<u8>> {
        if byte_len.unwrap_or(8) < 1 {
            return ::anyhow::__private::Err({
                let error = ::anyhow::__private::format_err(
                    format_args!("Byte length must be a positive integer"),
                );
                error
            });
        }
        let mut output: Vec<u8> = Vec::new();
        let delim = char_repr(delim.unwrap_or("Space"));
        for i in data.split(&delim) {
            match u8::from_str_radix(i, 16) {
                Ok(data) => output.push(data),
                Err(e) => {
                    return ::anyhow::__private::Err({
                        use ::anyhow::__private::kind::*;
                        let error = match e {
                            error => (&error).anyhow_kind().new(error),
                        };
                        error
                    });
                }
            }
        }
        Ok(output)
    }
    pub fn _from_decimal(data: &str, delim: Option<&str>) -> Result<Vec<usize>, String> {
        let mut output = Vec::new();
        for i in data.split(char_repr(delim.unwrap_or("Space"))) {
            match i.parse::<usize>() {
                Ok(data) => output.push(data),
                Err(e) => return Err(e.to_string()),
            }
        }
        Ok(output)
    }
    pub fn validate_lang(text: &str, lang: &SupportedLanguages) -> bool {
        let re = match lang {
            SupportedLanguages::EN => r"^[a-zA-Z\p{P}\s\d]+$",
            SupportedLanguages::RU => r"^[а-яА-Я\p{P}\s\d]+$",
            SupportedLanguages::RU_WITH_YO => r"^[а-яА-ЯёЁ\p{P}\s\d]+$",
        };
        {
            let regex = regex::Regex::new(re).unwrap();
            regex.is_match(text)
        }
    }
    pub fn get_alphabet(
        lang: &SupportedLanguages,
    ) -> (&'static str, &'static str, &'static str, &'static str, u8, &'static str) {
        match lang {
            SupportedLanguages::EN => EN_ALP,
            SupportedLanguages::RU => RU_ALP,
            SupportedLanguages::RU_WITH_YO => RU_ALP_WITH_YO,
        }
    }
    pub fn get_char_by_index<T: Integer + ToPrimitive>(text: &str, index: T) -> char {
        text.chars().nth(index.to_usize().unwrap()).unwrap()
    }
    pub fn get_index_by_char(text: &str, ch: char) -> usize {
        text.chars().position(|c| c == ch).unwrap()
    }
    pub fn char_repr(token: &str) -> &str {
        {
            let mut m = std::collections::HashMap::new();
            m.insert("Space", " ");
            m.insert("Percent", "%");
            m.insert("Comma", ",");
            m.insert("Semi-colon", ";");
            m.insert("Colon", ":");
            m.insert("Tab", "\t");
            m.insert("Line feed", "\n");
            m.insert("CRLF", "\r\n");
            m.insert("Forward slash", "/");
            m.insert("Backslash", "\\");
            m.insert("0x", "0x");
            m.insert("\\x", "\\x");
            m.insert("Nothing (separate chars)", "");
            m.insert("None", "");
            m
        }
            .get(token)
            .unwrap_or(&" ")
    }
    pub fn chr<T: ToPrimitive>(code: T) -> char {
        char::from_u32(code.to_u32().unwrap()).unwrap()
    }
    pub fn ord(chr: char) -> u32 {
        chr as u32
    }
    pub fn update_step<T: Integer + Copy>(a: &mut T, old_a: &mut T, quotient: T) {
        let temp = *a;
        *a = *old_a - quotient * temp;
        *old_a = temp;
    }
    pub fn extended_gcd<T: Integer + Copy>(a: T, b: T) -> (T, T, T) {
        let (mut old_r, mut rem) = (a, b);
        let (mut old_s, mut coefficient_s) = (T::one(), T::zero());
        let (mut old_t, mut coefficient_t) = (T::zero(), T::one());
        while rem != T::zero() {
            let quotient = old_r / rem;
            update_step(&mut rem, &mut old_r, quotient);
            update_step(&mut coefficient_s, &mut old_s, quotient);
            update_step(&mut coefficient_t, &mut old_t, quotient);
        }
        (old_r, old_s, old_t)
    }
    pub fn mod_inv<T: Integer + Copy>(a: T, module: T) -> T {
        let (_, x, _) = extended_gcd(a, module);
        if x < T::zero() { x + module } else { x }
    }
    pub fn modulus<T: Integer + Copy>(x: T, y: T) -> T {
        ((x % y) + y) % y
    }
    pub fn add(a: i16, b: i16) -> i16 {
        a + b
    }
    pub fn sub(a: i16, b: i16) -> i16 {
        a - b
    }
    pub fn hex<T: Debug + LowerHex>(c: T) -> String {
        {
            let res = ::alloc::fmt::format(format_args!("{0:08x}", c));
            res
        }
    }
}
use anyhow::{Error, Result};
pub use operations::*;
use serde::{Deserialize, Serialize};
use traits::StringTrait;
pub fn run_operations<'a, I>(
    operations: impl Operation<'a, I>,
    request: &str,
) -> Result<String>
where
    I: Deserialize<'a>,
{
    operations.do_black_magic(request)
}
pub trait Operation<'a, I>
where
    I: Deserialize<'a>,
{
    fn do_black_magic(&self, request: &str) -> Result<String>;
    fn validate(&self, request: &'a str) -> Result<I> {
        Ok(self.deserialize(request)?)
    }
    fn deserialize(&self, request: &'a str) -> Result<I> {
        serde_json::from_str(request)
            .map_err(|err| {
                Error::msg(
                    match err.to_string() {
                        err if err.starts_with("unknown") || err.starts_with("missing")
                            || err.starts_with("invalid") => {
                            err
                                .split(" at line ")
                                .next()
                                .unwrap()
                                .to_string()
                                .capitalize() + "."
                        }
                        err => err.capitalize() + ".",
                    },
                )
            })
    }
}
pub enum Operations {
    A1Z26CipherDecode,
    A1Z26CipherEncode,
    Adler32CheckSum,
    AffineCipherDecode,
    AffineCipherEncode,
    AnalyseHash,
    Argon2Compare,
    Argon2,
    AtbashCipher,
    BaconCipherEncode,
    BaconCipherDecode,
    BcryptCompare,
    Bcrypt,
    BcryptParse,
    BifidCipherEncode,
    Blake2b,
    Blake2s,
    FromBase64,
    FromBase,
    HMAC,
    MD2,
    MD4,
    MD5,
    RSADecrypt,
    RSAEncrypt,
    SHA1,
    SHA2,
    SHA3,
    ToBase64,
    ToBase,
    VigenereCipherDecode,
    VigenereCipherEncode,
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for Operations {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            match *self {
                Operations::A1Z26CipherDecode => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Operations",
                        0u32,
                        "A1Z26CipherDecode",
                    )
                }
                Operations::A1Z26CipherEncode => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Operations",
                        1u32,
                        "A1Z26CipherEncode",
                    )
                }
                Operations::Adler32CheckSum => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Operations",
                        2u32,
                        "Adler32CheckSum",
                    )
                }
                Operations::AffineCipherDecode => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Operations",
                        3u32,
                        "AffineCipherDecode",
                    )
                }
                Operations::AffineCipherEncode => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Operations",
                        4u32,
                        "AffineCipherEncode",
                    )
                }
                Operations::AnalyseHash => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Operations",
                        5u32,
                        "AnalyseHash",
                    )
                }
                Operations::Argon2Compare => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Operations",
                        6u32,
                        "Argon2Compare",
                    )
                }
                Operations::Argon2 => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Operations",
                        7u32,
                        "Argon2",
                    )
                }
                Operations::AtbashCipher => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Operations",
                        8u32,
                        "AtbashCipher",
                    )
                }
                Operations::BaconCipherEncode => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Operations",
                        9u32,
                        "BaconCipherEncode",
                    )
                }
                Operations::BaconCipherDecode => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Operations",
                        10u32,
                        "BaconCipherDecode",
                    )
                }
                Operations::BcryptCompare => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Operations",
                        11u32,
                        "BcryptCompare",
                    )
                }
                Operations::Bcrypt => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Operations",
                        12u32,
                        "Bcrypt",
                    )
                }
                Operations::BcryptParse => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Operations",
                        13u32,
                        "BcryptParse",
                    )
                }
                Operations::BifidCipherEncode => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Operations",
                        14u32,
                        "BifidCipherEncode",
                    )
                }
                Operations::Blake2b => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Operations",
                        15u32,
                        "Blake2b",
                    )
                }
                Operations::Blake2s => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Operations",
                        16u32,
                        "Blake2s",
                    )
                }
                Operations::FromBase64 => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Operations",
                        17u32,
                        "FromBase64",
                    )
                }
                Operations::FromBase => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Operations",
                        18u32,
                        "FromBase",
                    )
                }
                Operations::HMAC => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Operations",
                        19u32,
                        "HMAC",
                    )
                }
                Operations::MD2 => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Operations",
                        20u32,
                        "MD2",
                    )
                }
                Operations::MD4 => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Operations",
                        21u32,
                        "MD4",
                    )
                }
                Operations::MD5 => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Operations",
                        22u32,
                        "MD5",
                    )
                }
                Operations::RSADecrypt => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Operations",
                        23u32,
                        "RSADecrypt",
                    )
                }
                Operations::RSAEncrypt => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Operations",
                        24u32,
                        "RSAEncrypt",
                    )
                }
                Operations::SHA1 => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Operations",
                        25u32,
                        "SHA1",
                    )
                }
                Operations::SHA2 => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Operations",
                        26u32,
                        "SHA2",
                    )
                }
                Operations::SHA3 => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Operations",
                        27u32,
                        "SHA3",
                    )
                }
                Operations::ToBase64 => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Operations",
                        28u32,
                        "ToBase64",
                    )
                }
                Operations::ToBase => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Operations",
                        29u32,
                        "ToBase",
                    )
                }
                Operations::VigenereCipherDecode => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Operations",
                        30u32,
                        "VigenereCipherDecode",
                    )
                }
                Operations::VigenereCipherEncode => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Operations",
                        31u32,
                        "VigenereCipherEncode",
                    )
                }
            }
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for Operations {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
                __field4,
                __field5,
                __field6,
                __field7,
                __field8,
                __field9,
                __field10,
                __field11,
                __field12,
                __field13,
                __field14,
                __field15,
                __field16,
                __field17,
                __field18,
                __field19,
                __field20,
                __field21,
                __field22,
                __field23,
                __field24,
                __field25,
                __field26,
                __field27,
                __field28,
                __field29,
                __field30,
                __field31,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "variant identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        4u64 => _serde::__private::Ok(__Field::__field4),
                        5u64 => _serde::__private::Ok(__Field::__field5),
                        6u64 => _serde::__private::Ok(__Field::__field6),
                        7u64 => _serde::__private::Ok(__Field::__field7),
                        8u64 => _serde::__private::Ok(__Field::__field8),
                        9u64 => _serde::__private::Ok(__Field::__field9),
                        10u64 => _serde::__private::Ok(__Field::__field10),
                        11u64 => _serde::__private::Ok(__Field::__field11),
                        12u64 => _serde::__private::Ok(__Field::__field12),
                        13u64 => _serde::__private::Ok(__Field::__field13),
                        14u64 => _serde::__private::Ok(__Field::__field14),
                        15u64 => _serde::__private::Ok(__Field::__field15),
                        16u64 => _serde::__private::Ok(__Field::__field16),
                        17u64 => _serde::__private::Ok(__Field::__field17),
                        18u64 => _serde::__private::Ok(__Field::__field18),
                        19u64 => _serde::__private::Ok(__Field::__field19),
                        20u64 => _serde::__private::Ok(__Field::__field20),
                        21u64 => _serde::__private::Ok(__Field::__field21),
                        22u64 => _serde::__private::Ok(__Field::__field22),
                        23u64 => _serde::__private::Ok(__Field::__field23),
                        24u64 => _serde::__private::Ok(__Field::__field24),
                        25u64 => _serde::__private::Ok(__Field::__field25),
                        26u64 => _serde::__private::Ok(__Field::__field26),
                        27u64 => _serde::__private::Ok(__Field::__field27),
                        28u64 => _serde::__private::Ok(__Field::__field28),
                        29u64 => _serde::__private::Ok(__Field::__field29),
                        30u64 => _serde::__private::Ok(__Field::__field30),
                        31u64 => _serde::__private::Ok(__Field::__field31),
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 32",
                                ),
                            )
                        }
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "A1Z26CipherDecode" => _serde::__private::Ok(__Field::__field0),
                        "A1Z26CipherEncode" => _serde::__private::Ok(__Field::__field1),
                        "Adler32CheckSum" => _serde::__private::Ok(__Field::__field2),
                        "AffineCipherDecode" => _serde::__private::Ok(__Field::__field3),
                        "AffineCipherEncode" => _serde::__private::Ok(__Field::__field4),
                        "AnalyseHash" => _serde::__private::Ok(__Field::__field5),
                        "Argon2Compare" => _serde::__private::Ok(__Field::__field6),
                        "Argon2" => _serde::__private::Ok(__Field::__field7),
                        "AtbashCipher" => _serde::__private::Ok(__Field::__field8),
                        "BaconCipherEncode" => _serde::__private::Ok(__Field::__field9),
                        "BaconCipherDecode" => _serde::__private::Ok(__Field::__field10),
                        "BcryptCompare" => _serde::__private::Ok(__Field::__field11),
                        "Bcrypt" => _serde::__private::Ok(__Field::__field12),
                        "BcryptParse" => _serde::__private::Ok(__Field::__field13),
                        "BifidCipherEncode" => _serde::__private::Ok(__Field::__field14),
                        "Blake2b" => _serde::__private::Ok(__Field::__field15),
                        "Blake2s" => _serde::__private::Ok(__Field::__field16),
                        "FromBase64" => _serde::__private::Ok(__Field::__field17),
                        "FromBase" => _serde::__private::Ok(__Field::__field18),
                        "HMAC" => _serde::__private::Ok(__Field::__field19),
                        "MD2" => _serde::__private::Ok(__Field::__field20),
                        "MD4" => _serde::__private::Ok(__Field::__field21),
                        "MD5" => _serde::__private::Ok(__Field::__field22),
                        "RSADecrypt" => _serde::__private::Ok(__Field::__field23),
                        "RSAEncrypt" => _serde::__private::Ok(__Field::__field24),
                        "SHA1" => _serde::__private::Ok(__Field::__field25),
                        "SHA2" => _serde::__private::Ok(__Field::__field26),
                        "SHA3" => _serde::__private::Ok(__Field::__field27),
                        "ToBase64" => _serde::__private::Ok(__Field::__field28),
                        "ToBase" => _serde::__private::Ok(__Field::__field29),
                        "VigenereCipherDecode" => {
                            _serde::__private::Ok(__Field::__field30)
                        }
                        "VigenereCipherEncode" => {
                            _serde::__private::Ok(__Field::__field31)
                        }
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                            )
                        }
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"A1Z26CipherDecode" => _serde::__private::Ok(__Field::__field0),
                        b"A1Z26CipherEncode" => _serde::__private::Ok(__Field::__field1),
                        b"Adler32CheckSum" => _serde::__private::Ok(__Field::__field2),
                        b"AffineCipherDecode" => _serde::__private::Ok(__Field::__field3),
                        b"AffineCipherEncode" => _serde::__private::Ok(__Field::__field4),
                        b"AnalyseHash" => _serde::__private::Ok(__Field::__field5),
                        b"Argon2Compare" => _serde::__private::Ok(__Field::__field6),
                        b"Argon2" => _serde::__private::Ok(__Field::__field7),
                        b"AtbashCipher" => _serde::__private::Ok(__Field::__field8),
                        b"BaconCipherEncode" => _serde::__private::Ok(__Field::__field9),
                        b"BaconCipherDecode" => _serde::__private::Ok(__Field::__field10),
                        b"BcryptCompare" => _serde::__private::Ok(__Field::__field11),
                        b"Bcrypt" => _serde::__private::Ok(__Field::__field12),
                        b"BcryptParse" => _serde::__private::Ok(__Field::__field13),
                        b"BifidCipherEncode" => _serde::__private::Ok(__Field::__field14),
                        b"Blake2b" => _serde::__private::Ok(__Field::__field15),
                        b"Blake2s" => _serde::__private::Ok(__Field::__field16),
                        b"FromBase64" => _serde::__private::Ok(__Field::__field17),
                        b"FromBase" => _serde::__private::Ok(__Field::__field18),
                        b"HMAC" => _serde::__private::Ok(__Field::__field19),
                        b"MD2" => _serde::__private::Ok(__Field::__field20),
                        b"MD4" => _serde::__private::Ok(__Field::__field21),
                        b"MD5" => _serde::__private::Ok(__Field::__field22),
                        b"RSADecrypt" => _serde::__private::Ok(__Field::__field23),
                        b"RSAEncrypt" => _serde::__private::Ok(__Field::__field24),
                        b"SHA1" => _serde::__private::Ok(__Field::__field25),
                        b"SHA2" => _serde::__private::Ok(__Field::__field26),
                        b"SHA3" => _serde::__private::Ok(__Field::__field27),
                        b"ToBase64" => _serde::__private::Ok(__Field::__field28),
                        b"ToBase" => _serde::__private::Ok(__Field::__field29),
                        b"VigenereCipherDecode" => {
                            _serde::__private::Ok(__Field::__field30)
                        }
                        b"VigenereCipherEncode" => {
                            _serde::__private::Ok(__Field::__field31)
                        }
                        _ => {
                            let __value = &_serde::__private::from_utf8_lossy(__value);
                            _serde::__private::Err(
                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                            )
                        }
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<Operations>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = Operations;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "enum Operations",
                    )
                }
                fn visit_enum<__A>(
                    self,
                    __data: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::EnumAccess<'de>,
                {
                    match _serde::de::EnumAccess::variant(__data)? {
                        (__Field::__field0, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Operations::A1Z26CipherDecode)
                        }
                        (__Field::__field1, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Operations::A1Z26CipherEncode)
                        }
                        (__Field::__field2, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Operations::Adler32CheckSum)
                        }
                        (__Field::__field3, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Operations::AffineCipherDecode)
                        }
                        (__Field::__field4, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Operations::AffineCipherEncode)
                        }
                        (__Field::__field5, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Operations::AnalyseHash)
                        }
                        (__Field::__field6, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Operations::Argon2Compare)
                        }
                        (__Field::__field7, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Operations::Argon2)
                        }
                        (__Field::__field8, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Operations::AtbashCipher)
                        }
                        (__Field::__field9, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Operations::BaconCipherEncode)
                        }
                        (__Field::__field10, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Operations::BaconCipherDecode)
                        }
                        (__Field::__field11, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Operations::BcryptCompare)
                        }
                        (__Field::__field12, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Operations::Bcrypt)
                        }
                        (__Field::__field13, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Operations::BcryptParse)
                        }
                        (__Field::__field14, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Operations::BifidCipherEncode)
                        }
                        (__Field::__field15, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Operations::Blake2b)
                        }
                        (__Field::__field16, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Operations::Blake2s)
                        }
                        (__Field::__field17, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Operations::FromBase64)
                        }
                        (__Field::__field18, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Operations::FromBase)
                        }
                        (__Field::__field19, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Operations::HMAC)
                        }
                        (__Field::__field20, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Operations::MD2)
                        }
                        (__Field::__field21, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Operations::MD4)
                        }
                        (__Field::__field22, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Operations::MD5)
                        }
                        (__Field::__field23, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Operations::RSADecrypt)
                        }
                        (__Field::__field24, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Operations::RSAEncrypt)
                        }
                        (__Field::__field25, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Operations::SHA1)
                        }
                        (__Field::__field26, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Operations::SHA2)
                        }
                        (__Field::__field27, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Operations::SHA3)
                        }
                        (__Field::__field28, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Operations::ToBase64)
                        }
                        (__Field::__field29, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Operations::ToBase)
                        }
                        (__Field::__field30, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Operations::VigenereCipherDecode)
                        }
                        (__Field::__field31, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Operations::VigenereCipherEncode)
                        }
                    }
                }
            }
            #[doc(hidden)]
            const VARIANTS: &'static [&'static str] = &[
                "A1Z26CipherDecode",
                "A1Z26CipherEncode",
                "Adler32CheckSum",
                "AffineCipherDecode",
                "AffineCipherEncode",
                "AnalyseHash",
                "Argon2Compare",
                "Argon2",
                "AtbashCipher",
                "BaconCipherEncode",
                "BaconCipherDecode",
                "BcryptCompare",
                "Bcrypt",
                "BcryptParse",
                "BifidCipherEncode",
                "Blake2b",
                "Blake2s",
                "FromBase64",
                "FromBase",
                "HMAC",
                "MD2",
                "MD4",
                "MD5",
                "RSADecrypt",
                "RSAEncrypt",
                "SHA1",
                "SHA2",
                "SHA3",
                "ToBase64",
                "ToBase",
                "VigenereCipherDecode",
                "VigenereCipherEncode",
            ];
            _serde::Deserializer::deserialize_enum(
                __deserializer,
                "Operations",
                VARIANTS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<Operations>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[automatically_derived]
impl ::core::fmt::Debug for Operations {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::write_str(
            f,
            match self {
                Operations::A1Z26CipherDecode => "A1Z26CipherDecode",
                Operations::A1Z26CipherEncode => "A1Z26CipherEncode",
                Operations::Adler32CheckSum => "Adler32CheckSum",
                Operations::AffineCipherDecode => "AffineCipherDecode",
                Operations::AffineCipherEncode => "AffineCipherEncode",
                Operations::AnalyseHash => "AnalyseHash",
                Operations::Argon2Compare => "Argon2Compare",
                Operations::Argon2 => "Argon2",
                Operations::AtbashCipher => "AtbashCipher",
                Operations::BaconCipherEncode => "BaconCipherEncode",
                Operations::BaconCipherDecode => "BaconCipherDecode",
                Operations::BcryptCompare => "BcryptCompare",
                Operations::Bcrypt => "Bcrypt",
                Operations::BcryptParse => "BcryptParse",
                Operations::BifidCipherEncode => "BifidCipherEncode",
                Operations::Blake2b => "Blake2b",
                Operations::Blake2s => "Blake2s",
                Operations::FromBase64 => "FromBase64",
                Operations::FromBase => "FromBase",
                Operations::HMAC => "HMAC",
                Operations::MD2 => "MD2",
                Operations::MD4 => "MD4",
                Operations::MD5 => "MD5",
                Operations::RSADecrypt => "RSADecrypt",
                Operations::RSAEncrypt => "RSAEncrypt",
                Operations::SHA1 => "SHA1",
                Operations::SHA2 => "SHA2",
                Operations::SHA3 => "SHA3",
                Operations::ToBase64 => "ToBase64",
                Operations::ToBase => "ToBase",
                Operations::VigenereCipherDecode => "VigenereCipherDecode",
                Operations::VigenereCipherEncode => "VigenereCipherEncode",
            },
        )
    }
}
#[serde(rename_all = "lowercase")]
pub enum OutputFormat {
    Hex(String),
    Base64(String),
    Uint8Array(Vec<u8>),
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for OutputFormat {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            match *self {
                OutputFormat::Hex(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "OutputFormat",
                        0u32,
                        "hex",
                        __field0,
                    )
                }
                OutputFormat::Base64(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "OutputFormat",
                        1u32,
                        "base64",
                        __field0,
                    )
                }
                OutputFormat::Uint8Array(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "OutputFormat",
                        2u32,
                        "uint8array",
                        __field0,
                    )
                }
            }
        }
    }
};
pub const DOCS_URL: &str = "soon I transfer all documentation to somewhere :/";
